<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lyogvce</title>
  <subtitle>Lyogvce&#39;s 博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.lyogvce.me/"/>
  <updated>2017-07-16T02:27:02.048Z</updated>
  <id>http://blog.lyogvce.me/</id>
  
  <author>
    <name>Lyogvce</name>
    <email>lyogvce@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git Flow &amp; Git 命令</title>
    <link href="http://blog.lyogvce.me/2017-06/Git_Flow_and_Git_Command.html"/>
    <id>http://blog.lyogvce.me/2017-06/Git_Flow_and_Git_Command.html</id>
    <published>2017-06-21T16:00:00.000Z</published>
    <updated>2017-07-16T02:27:02.048Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是针对 <strong>Git Flow &amp; Git 命令</strong> 的 <strong>总结</strong>。</p>
<p>我花费了很大精力才完成的！</p>
<a id="more"></a>
<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><h3 id="1-1-Git-V-S-SVN"><a href="#1-1-Git-V-S-SVN" class="headerlink" title="1.1 Git V.S. SVN"></a>1.1 Git V.S. SVN</h3><p>SVN 是 <strong>集中化</strong> 的版本控制系统, 虽然能够令多个团队成员一起协作开发, 但有时如果中央服务器宕机的话, 谁也无法在宕机期间提交更新和协同开发。甚至有时, 中央服务器磁盘故障, 恰巧又没有做备份或备份没及时, 那就可能有丢失数据的风险。</p>
<p>Git 是 <strong>分布式</strong> 的版本控制系统, 客户端不只是提取最新版本的快照, 而且将整个代码仓库镜像复制下来。如果任何协同工作用的服务器发生故障了, 也可以用任何一个代码仓库来恢复。而且在协作服务器宕机期间, 你也可以提交代码到本地仓库, 当协作服务器正常工作后, 你再将本地仓库同步到远程仓库。</p>
<h3 id="1-2-功能-amp-特性"><a href="#1-2-功能-amp-特性" class="headerlink" title="1.2 功能 &amp; 特性"></a>1.2 功能 &amp; 特性</h3><ul>
<li><strong>版本控制</strong> &amp; <strong>多人协作开发</strong></li>
<li>强大的 <strong>分支特性</strong>, 所以能够灵活地以 <strong>不同的工作流</strong> 协同开发</li>
<li><strong>分布式版本控制系统</strong>, 即使协作服务器宕机, 也能继续提交代码或文件到本地仓库, 当协作服务器恢复正常工作时, 再将本地仓库同步到远程仓库。</li>
<li>直接记录快照, 而非差异比较</li>
</ul>
<p>有关以上特性的详细解释, 请查看 Pro git 的 <a href="https://git-scm.com/book/zh/v2/起步-Git-基础" target="_blank" rel="external">git 基础章节</a></p>
<h3 id="1-3-Git-基本技巧"><a href="#1-3-Git-基本技巧" class="headerlink" title="1.3 Git 基本技巧"></a>1.3 Git 基本技巧</h3><h4 id="1-Git-命令别名"><a href="#1-Git-命令别名" class="headerlink" title="(1) Git 命令别名"></a>(1) Git 命令别名</h4><p>关于具体如何使用命名别名技巧, 请查看 Pro git 的<a href="https://git-scm.com/book/zh/v2/Git-基础-Git-别名" target="_blank" rel="external">技巧和窍门</a></p>
<h2 id="2-Git-Flow"><a href="#2-Git-Flow" class="headerlink" title="2. Git Flow"></a>2. Git Flow</h2><p>由于 git 拥有强大的 <strong>分支特性</strong>, 它的工作流比较灵活而缺乏约束, 于是参考 <a href="https://www.atlassian.com/git/tutorials" target="_blank" rel="external">Atlassian Git Tutorial</a> 的 <a href="https://www.atlassian.com/git/tutorials/comparing-workflows" target="_blank" rel="external">Comparing Workflows</a> 章节, 在此提供 <strong>五种 Git 工作流</strong>:</p>
<p><a href="#2.1-Basic-Workflow-基本工作流">2.1 Basic Workflow (基本工作流)</a><br><a href="#2.2-Centralized-Workflow-集中式工作流">2.2 Centralized Workflow (集中式工作流)</a><br><a href="#2.3-Feature-Branch-Workflow-功能分支工作流">2.3 Feature Branch Workflow (功能分支工作流)</a><br><a href="#2.4-Gitflow-Workflow-Gitflow-工作流">2.4 Gitflow Workflow (Gitflow 工作流)</a><br><a href="#2.5-Forking-Workflow-Forking-工作流">2.5 Forking Workflow (Forking 工作流)</a></p>
<p>最后会介绍一个集大成者: 一套 <a href="#2.6-Forking-Workflow-Forking-工作流">开发流程(分支策略和发布管理) 模型</a>, 先看图眼馋一下。</p>
<p><img src="../images/Git_Flow_and_Git_Command/0.jpg" alt="" title="一个成功的 Git 分支模型"></p>
<h3 id="2-1-Basic-Workflow-基本工作流"><a href="#2-1-Basic-Workflow-基本工作流" class="headerlink" title="2.1 Basic Workflow (基本工作流)"></a>2.1 Basic Workflow (基本工作流)</h3><ol>
<li>在 git 版本控制的目录下修改某个文件</li>
<li>使用 <code>git add</code> 命令对修改后的文件快照, 保存到暂存区域</li>
<li>使用 <code>git commit</code> 命令提交更新, 将保存在暂存区域的文件快照永久转储到 Git 目录中</li>
</ol>
<h3 id="2-2-Centralized-Workflow-集中式工作流"><a href="#2-2-Centralized-Workflow-集中式工作流" class="headerlink" title="2.2 Centralized Workflow (集中式工作流)"></a>2.2 Centralized Workflow (集中式工作流)</h3><p>过渡到分布式版本控制系统看起来像一个艰巨的任务, 但如果你充分利用好 git 的话, 你不必改变你既有的工作流, 你的团队可以采用与之前使用 SVN 一样的方式来开发项目。</p>
<h4 id="1-如何工作"><a href="#1-如何工作" class="headerlink" title="(1) 如何工作"></a>(1) 如何工作</h4><p><img src="../images/Git_Flow_and_Git_Command/1.jpg" alt="" title="Centralized Workflow"></p>
<ol>
<li>从远程仓库 (central repository) 克隆工程到本地仓库 (local repository) — <code>git clone</code></li>
<li>在本地仓库编辑文件和提交更新 — <code>git add</code> 和 <code>git commit</code></li>
<li>fetch 远程仓库已更新的 commit 到本地仓库和 rebase 到已更新的 commit 的上面 —<code>git fetch</code> 和 <code>git rebase</code> 或 <code>git pull --rebase</code></li>
<li>push 本地主分支 (master branch) 到远程仓库 — <code>git push</code></li>
</ol>
<h4 id="2-管理冲突"><a href="#2-管理冲突" class="headerlink" title="(2) 管理冲突"></a>(2) 管理冲突</h4><p><img src="../images/Git_Flow_and_Git_Command/2.jpg" alt="" title="File Conflicts"></p>
<ul>
<li><strong>何时发生冲突:</strong> 在开发者发布它们功能之前, 他们需要 fetch 远程仓库已更新的 commit 到本地仓库和 rebase 到已更新的 commit 的上面。有时, 本地提交与远程提交会发生冲突, git 会暂停 rebase 过程来让你手动解决冲突。</li>
<li><strong>如何解决冲突:</strong> 你可以使用 <code>git status</code> 和 <code>git add</code> 来手动解决合并时冲突。</li>
</ul>
<h3 id="2-3-Feature-Branch-Workflow-功能分支工作流"><a href="#2-3-Feature-Branch-Workflow-功能分支工作流" class="headerlink" title="2.3 Feature Branch Workflow (功能分支工作流)"></a>2.3 Feature Branch Workflow (功能分支工作流)</h3><p>Feature Branch Workflow 的主要思想就是在 <strong>开发每个功能</strong> 时都应该创建 <strong>一个独立的分支</strong> 而不只是使用主分支。由于每个分支是独立且互不影响, 这就意味着主分支不会包含 broken code, 对持续集成环境是很有帮助的。</p>
<h4 id="1-如何工作-1"><a href="#1-如何工作-1" class="headerlink" title="(1) 如何工作"></a>(1) 如何工作</h4><p><img src="../images/Git_Flow_and_Git_Command/3.jpg" alt="" title="Feature Branch Workflow"></p>
<ol>
<li>仍然使用远程仓库 (central repository) 和主分支 (master branch) 记录官方工程的历史</li>
<li>开发者每次开发新功能时都创建一个新分支 — <code>git checkout -b</code></li>
<li>Feature branches 应该推送到远程仓库 (central repository) — <code>git push</code></li>
<li>发送 pull request 来请求管理员能否合并到主分支 (master branch)</li>
<li>发布新功能到远程仓库 (central repository)</li>
</ol>
<h4 id="2-Pull-Request"><a href="#2-Pull-Request" class="headerlink" title="(2) Pull Request"></a>(2) Pull Request</h4><p><strong>Pull request</strong> 是一种当开发者完成一个新功能后向其他团队成员发送通知的机制。它的使用过程如下:</p>
<p><img src="../images/Git_Flow_and_Git_Command/4.jpg" alt="" title="Pull request on Github"></p>
<ul>
<li>开发者可以通过 Github 或 Bitbucket 发送 pull request</li>
<li>其他的团队成员审查、讨论和修改代码</li>
<li>项目维护者合并新增功能分支到主分支 (master branch), 然后关闭 pull request</li>
</ul>
<h3 id="2-4-Gitflow-Workflow-Gitflow-工作流"><a href="#2-4-Gitflow-Workflow-Gitflow-工作流" class="headerlink" title="2.4 Gitflow Workflow (Gitflow 工作流)"></a>2.4 Gitflow Workflow (Gitflow 工作流)</h3><p>Feature Branch Workflow 是一种非常灵活的开发方式。对于一些规模比较大的团队, 最好就是给特定的分支赋予不同的角色。除了 <strong>功能分支 (feature branch)</strong>, Gitflow Workflow 还使用独立的分支来 <strong>准备发布 (preparing)</strong>、<strong>维护 (maintaining)</strong> 和 <strong>记录版本 (recording releases)</strong>。下面我会逐个介绍这个几个分支: Historical Branches、Feature Branches、Release Branches 和 Maintenance Branches。</p>
<h4 id="1-Historical-Branches"><a href="#1-Historical-Branches" class="headerlink" title="(1) Historical Branches"></a>(1) Historical Branches</h4><p><img src="../images/Git_Flow_and_Git_Command/5.jpg" alt="" title="Historical Branches"></p>
<ul>
<li><strong>master 分支</strong> 保存官方发布历史</li>
<li><strong>develop 分支</strong> 衍生出各个 feature 分支</li>
</ul>
<h4 id="2-Feature-Branches"><a href="#2-Feature-Branches" class="headerlink" title="(2) Feature Branches"></a>(2) Feature Branches</h4><p><img src="../images/Git_Flow_and_Git_Command/6.jpg" alt="" title="Feature Branches"></p>
<ul>
<li><strong>feature 分支</strong> 使用 develop 分支作为它们的父类分支</li>
<li>当其中一个 feature 分支完成后, 它会合并会 develop 分支</li>
<li>feature 分支应该从不与 master 分支直接交互</li>
</ul>
<h4 id="3-Release-Branches"><a href="#3-Release-Branches" class="headerlink" title="(3) Release Branches"></a>(3) Release Branches</h4><p><img src="../images/Git_Flow_and_Git_Command/7.jpg" alt="" title="Release Branches"></p>
<ul>
<li><strong>release 分支</strong> 主要用来清理释放、测试和更新文档</li>
<li>一旦 develop 分支获得足够的功能来发布时, 你可以从 develop 衍生出一个 release 分支</li>
<li>一旦准备好上架, release 合并到 master 分支并且标记一个版本号</li>
<li>另外, 还需要合并回 develop 分支</li>
</ul>
<h4 id="4-Maintenance-Branches"><a href="#4-Maintenance-Branches" class="headerlink" title="(4) Maintenance Branches"></a>(4) Maintenance Branches</h4><p><img src="../images/Git_Flow_and_Git_Command/8.jpg" alt="" title="Maintenance Branches"></p>
<ul>
<li><strong>maintenance 分支</strong> 用来快速给已发布产品修复 bug 或微调功能</li>
<li>它从 master 分支直接衍生出来</li>
<li>一旦完成修复 bug, 它应该合并回 master 分支和 develop 分支</li>
<li>master 应该被标记一个新的版本号</li>
</ul>
<h4 id="5-标记-Tags"><a href="#5-标记-Tags" class="headerlink" title="(5) 标记 Tags"></a>(5) 标记 Tags</h4><p>使用两个命令来给 master 分支标记版本号:</p>
<ul>
<li><code>git tag -a 0.1 -m &quot;Initial public release&quot; master</code></li>
<li><code>git push origin master --tags</code></li>
</ul>
<h3 id="2-5-Forking-Workflow-Forking-工作流"><a href="#2-5-Forking-Workflow-Forking-工作流" class="headerlink" title="2.5 Forking Workflow (Forking 工作流)"></a>2.5 Forking Workflow (Forking 工作流)</h3><p>Forking Workflow 与以上讨论的工作流很不同, 一个很重要的 <strong>区别</strong> 就是它不只是多个开发共享一个远程仓库 (central repository), 而是每个开发者都拥有一个独立的服务端仓库。也就是说每个 contributor 都有两个仓库: 自己的私有的远程仓库和官方的共享的远程仓库。</p>
<p><img src="../images/Git_Flow_and_Git_Command/9.jpg" alt="" title="Forking Workflow"></p>
<p>Forking Workflow 这种工作流主要好处就是每个开发者都拥有自己的远程仓库, 可以将提交的 commits 推送到自己的远程仓库, 但只有工程维护者才有权限 push 提交的 commits 到官方的仓库, 其他开发者在没有授权的情况下不能 push。Github 很多 <strong>开源项目</strong> 都是采用 Forking Workflow 工作流。</p>
<h4 id="1-如何工作-2"><a href="#1-如何工作-2" class="headerlink" title="(1) 如何工作"></a>(1) 如何工作</h4><p><img src="../images/Git_Flow_and_Git_Command/10.jpg" alt="" title="Fork official repository"></p>
<ol>
<li>在服务器上有一个官方公共的仓库</li>
<li>开发者 fork 官方仓库来创建它的拷贝, 然后存放在服务器上</li>
<li>当开发者准备好发布本地的 commit 时, 他们 push commit 到他们自己的公共仓库</li>
<li>在自己的公共仓库发送一个 pull request 到官方仓库</li>
<li>维护者 pull 贡献者的 commit 到他自己的本地仓库</li>
<li>审查代码确保它不会破坏工程, 合并它到本地仓库的 master 分支</li>
<li>push master 分支到服务器上的官方仓库</li>
<li>其他开发者应该同步官方仓库。</li>
</ol>
<h3 id="2-6-终极开发流程-分支策略和发布管理-模型"><a href="#2-6-终极开发流程-分支策略和发布管理-模型" class="headerlink" title="2.6 终极开发流程 (分支策略和发布管理) 模型"></a>2.6 终极开发流程 (分支策略和发布管理) 模型</h3><p>先上图。</p>
<p><img src="../images/Git_Flow_and_Git_Command/0.jpg" alt="" title="一个成功的 Git 分支模型"></p>
<p>本节全部来自这篇文章: <a href="http://blog.jobbole.com/81196" target="_blank" rel="external">一个成功的 Git 分支模型</a>, 原文与译文都不错, 我就不转载了, 直接去看吧。</p>
<h2 id="3-Git-命令清单"><a href="#3-Git-命令清单" class="headerlink" title="3. Git 命令清单"></a>3. Git 命令清单</h2><p>一般来说, 日常使用只要记住下图 6 个命令, 就可以了。但是熟练使用, 恐怕要记住 60～100 个命令。</p>
<p><img src="../images/Git_Flow_and_Git_Command/11.png" alt=""></p>
<p>下面是一份常用 Git 命令清单。几个专用名词的译名如下。</p>
<ul>
<li>Workspace: 工作区</li>
<li>Index / Stage: 暂存区</li>
<li>Repository: 本地仓库</li>
<li>Remote: 远程仓库</li>
</ul>
<p>你的本地仓库由 git 维护的三棵 “树” 组成。第一个是你的 <code>工作目录</code>, 它持有实际文件; 第二个是 <code>暂存区(Index/Stage)</code>, 它像个缓存区域, 临时保存你的改动; 最后是 <code>HEAD</code>, 它指向你最后一次提交的结果。</p>
<p>文件状态</p>
<ul>
<li>未跟踪 Untracked</li>
<li>已跟踪 Tracked<ul>
<li>已修改 modified</li>
<li>已放入暂存区 staged</li>
<li>未修改 committed</li>
</ul>
</li>
</ul>
<h3 id="3-1-配置与帮助-config-help"><a href="#3-1-配置与帮助-config-help" class="headerlink" title="3.1 配置与帮助 config help"></a>3.1 配置与帮助 config help</h3><p>Git 的设置文件为 <code>.gitconfig</code>, 它可以在用户主目录下(全局配置), 也可以在项目目录下(项目配置)。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 显示当前的 Git 配置</span></div><div class="line">$ git config --list</div><div class="line"></div><div class="line"><span class="comment"># 编辑 Git 配置文件</span></div><div class="line">$ git config -e [--global]</div><div class="line"></div><div class="line"><span class="comment"># 设置提交代码时的用户信息</span></div><div class="line">$ git config [--global] user.name <span class="string">"[name]"</span></div><div class="line">$ git config [--global] user.email <span class="string">"[email address]"</span></div><div class="line"></div><div class="line"><span class="comment"># 其它的一些重要配置</span></div><div class="line">$ git config [--global] core.quotepath <span class="literal">false</span> <span class="comment"># 使 git 命令输出中的中文正确显示</span></div><div class="line">$ git config [--global] core.editor</div><div class="line">$ git config [--global] diff.tool</div><div class="line">$ git config [--global] merge.tool</div><div class="line">$ git config [--global] help.format</div><div class="line"></div><div class="line"><span class="comment"># 设置彩色输出, 一般默认就是</span></div><div class="line">$ git config [--global] color.ui <span class="literal">true</span></div><div class="line"></div><div class="line"><span class="comment"># 显示帮助信息</span></div><div class="line"><span class="comment"># -i: info 形式展示 -m: man 形式展示 -w: web(html)形式展示。windows 的 git bash 没有 man, 只能 web 形式展示</span></div><div class="line">$ git <span class="built_in">help</span></div><div class="line">$ git <span class="built_in">help</span> [<span class="built_in">command</span>]</div><div class="line">$ git [<span class="built_in">command</span>] --<span class="built_in">help</span></div></pre></td></tr></table></figure>
<h3 id="3-2-新建代码库-init-clone"><a href="#3-2-新建代码库-init-clone" class="headerlink" title="3.2 新建代码库 init clone"></a>3.2 新建代码库 init clone</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 将当前目录初始化为 Git 代码库</span></div><div class="line">$ git init</div><div class="line"></div><div class="line"><span class="comment"># 在当前目录新建一个目录, 并将其初始化为 Git 代码库</span></div><div class="line">$ git init [project-name]</div><div class="line"></div><div class="line"><span class="comment"># 创建远端仓库的克隆 [指定目录名]</span></div><div class="line">$ git <span class="built_in">clone</span> [url]</div><div class="line">$ git <span class="built_in">clone</span> [url] [dir-name]</div><div class="line"></div><div class="line"><span class="comment"># 指定远程主机名(默认 origin)</span></div><div class="line">$ git <span class="built_in">clone</span> -o [remote-name] [url]</div><div class="line"></div><div class="line"><span class="comment"># 创建本地仓库的克隆 [指定目录名]</span></div><div class="line">$ git <span class="built_in">clone</span> /path/to/repository</div><div class="line">$ git <span class="built_in">clone</span> /path/to/repository [dir-name]</div></pre></td></tr></table></figure>
<h3 id="3-3-增加-删除-移动文件-add-rm-mv"><a href="#3-3-增加-删除-移动文件-add-rm-mv" class="headerlink" title="3.3 增加 / 删除 / 移动文件 add rm mv"></a>3.3 增加 / 删除 / 移动文件 add rm mv</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 开始跟踪文件并放到暂存区 或 把已跟踪文件放到暂存区 或 合并时把有冲突的文件标记为已解决状态</span></div><div class="line">$ git add [file1] [file2] ...</div><div class="line"></div><div class="line"><span class="comment"># 添加指定目录到暂存区, 包括子目录</span></div><div class="line">$ git add [dir]</div><div class="line"></div><div class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></div><div class="line">$ git add .</div><div class="line"></div><div class="line"><span class="comment"># 对每个变化都会要求确认是否 Stage, 对于同一个文件的多处变化, 可以实现部分提交、分次提交</span></div><div class="line">$ git add -p</div><div class="line"></div><div class="line"><span class="comment"># 停止追踪指定文件, 但该文件会保留在工作区</span></div><div class="line">$ git rm --cached [file]</div><div class="line"></div><div class="line"><span class="comment"># 删除工作区文件, 并且将这次删除放入暂存区</span></div><div class="line">$ git rm [file1] [file2] ...</div><div class="line"></div><div class="line"><span class="comment"># 改名文件, 并且将这个改名放入暂存区</span></div><div class="line">$ git mv [file-original] [file-renamed]</div></pre></td></tr></table></figure>
<h3 id="3-4-提交-commit"><a href="#3-4-提交-commit" class="headerlink" title="3.4 提交 commit"></a>3.4 提交 commit</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 提交暂存区到仓库区</span></div><div class="line">$ git commit -m [message]</div><div class="line"></div><div class="line"><span class="comment"># 提交暂存区的指定文件到仓库区</span></div><div class="line">$ git commit [file1] [file2] ... -m [message]</div><div class="line"></div><div class="line"><span class="comment"># 提交工作区自上次 commit 之后的变化, 直接到仓库区(省下 git add 操作)(但是只有已追踪文件的更改会提交, 未追踪文件还是要先 git add)</span></div><div class="line">$ git commit -a -m [message]</div><div class="line"></div><div class="line"><span class="comment"># 提交时显示所有 diff 信息</span></div><div class="line">$ git commit -v</div><div class="line"></div><div class="line"><span class="comment"># 用一次新的提交(新的 commit id), 重写最近一次提交(并包括所有新变化)。如果没有文件更改, 也可以用来改写上一次 commit 的提交信息</span></div><div class="line">$ git commit --amend -m [message]</div><div class="line"></div><div class="line"><span class="comment"># 重写上一次 commit, 并包括指定文件的新变化</span></div><div class="line">$ git commit --amend [file1] [file2] ... -m [message]</div></pre></td></tr></table></figure>
<h3 id="3-5-分支-branch-checkout-merge-rebase-cherry-pick"><a href="#3-5-分支-branch-checkout-merge-rebase-cherry-pick" class="headerlink" title="3.5 分支 branch checkout merge rebase cherry-pick"></a>3.5 分支 branch checkout merge rebase cherry-pick</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 列出所有本地分支</span></div><div class="line">$ git branch</div><div class="line"></div><div class="line"><span class="comment"># 列出所有远程分支, 远程分支: 除了 Git 不允许你检出 (切换到该分支) 之外, 远程分支跟本地分支没区别 --- 你可以将它们合并到当前分支(merge、rebase), 与其他分支作比较差异(diff), 查看那些分支的历史日志(log), 等等。PS: 在本地主机上要用 "远程主机名/分支名" 的形式访问。</span></div><div class="line">$ git branch -r</div><div class="line"></div><div class="line"><span class="comment"># 列出所有本地分支和远程分支</span></div><div class="line">$ git branch -a</div><div class="line">* master</div><div class="line">  dev-1</div><div class="line">  remotes/origin/master</div><div class="line">  remotes/origin/dev-1</div><div class="line"><span class="comment"># 表示, 本地主机的当前分支是 master, 远程分支有 origin/master origin/dev-1</span></div><div class="line"></div><div class="line"><span class="comment"># 新建一个分支(以当前分支为基础), 但依然停留在当前分支</span></div><div class="line">$ git branch [new-branch-name]</div><div class="line"></div><div class="line"><span class="comment"># 新建一个分支(以当前分支为基础), 并切换到该分支</span></div><div class="line">$ git checkout -b [new-branch-name]</div><div class="line"></div><div class="line"><span class="comment"># 新建一个分支(以指定的本地分支为基础)</span></div><div class="line">$ git branch [new-branch-name] [branch-name]</div><div class="line">$ git checkout -b [new-branch-name] [branch-name]</div><div class="line"></div><div class="line"><span class="comment"># 新建一个分支(以指定的远程分支为基础, 会自动建立追溯关系)</span></div><div class="line">$ git branch [new-branch-name] [origin/master]</div><div class="line">$ git checkout -b [new-branch-name] [origin/master]</div><div class="line"></div><div class="line"><span class="comment"># 新建一个分支, 以指定 commit 为基础</span></div><div class="line">$ git branch [new-branch-name] [commit]</div><div class="line">$ git checkout -b [new-branch-name] [commit]</div><div class="line"></div><div class="line"><span class="comment"># 将现有分支与指定的远程分支建立追踪关系</span></div><div class="line">$ git branch --<span class="built_in">set</span>-upstream [branch-name] [remote-branch]</div><div class="line"></div><div class="line"><span class="comment"># 创建一个空白分支: 1. 创建一个 orphan 的分支, 这个分支是独立的 2. 删除原来代码树下的所有文件</span></div><div class="line">$ git checkout --orphan [branch-name]</div><div class="line">$ git rm -rf .</div><div class="line"><span class="comment"># 注意这个时候你用 git branch 命令是看不见当前分支的名字的(无任何提交的分支都看不见), 除非你进行了第一次 commit</span></div><div class="line"></div><div class="line"><span class="comment"># 切换到指定分支, 并更新工作区(未提交的就没了! 解决方案见 git stash)</span></div><div class="line">$ git checkout [branch-name]</div><div class="line"></div><div class="line"><span class="comment"># 切换到上一个分支</span></div><div class="line">$ git checkout -</div><div class="line"></div><div class="line"><span class="comment"># 删除本地分支</span></div><div class="line">$ git branch -d [branch-name]</div><div class="line"></div><div class="line"><span class="comment"># 删除远程分支</span></div><div class="line">$ git push [remote-name] --delete [remote-branch-name]</div><div class="line">$ git push [remote-name] :[remote-branch-name]</div><div class="line">$ git branch -dr [remote-name/remote-branch-name]</div><div class="line"></div><div class="line"><span class="comment"># 合并指定本地分支/远程分支 (要用 "远程主机名/分支名" 的形式访问) 到当前分支</span></div><div class="line">$ git merge [branch-name]</div><div class="line">$ git merge [remote-name/branch-name]</div><div class="line"></div><div class="line"><span class="comment"># 左: 非快进式合并(会多一个节点)   右: 快进式合并</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># * 2d3acf9 ****               * 2d3acf9 ****</span></div><div class="line"><span class="comment"># *  5e3ee11 Merge branch **** |</span></div><div class="line"><span class="comment"># |\                           |</span></div><div class="line"><span class="comment"># | * 420eac9 ****             * 420eac9 ****</span></div><div class="line"><span class="comment"># | * 30e367c ****             * 30e367c ****</span></div><div class="line"><span class="comment"># | * 5a09431 ****             * 5a09431 ****</span></div><div class="line"><span class="comment"># | * e1193f8 ****             * e1193f8 ****</span></div><div class="line"><span class="comment"># |/                           |</span></div><div class="line"><span class="comment"># * d6016bc ****               * d6016bc ****</span></div><div class="line"><span class="comment"># * 11d191e ****               * 11d191e ****</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># 非快进式合并可以刻意地弄出提交线图分叉(如上图: 本可以合并为一条提交线), 更清晰地告诉你同伴: 这一系列的提交都是为了实现同一个目的(一般是从 feature 分支合并过来的)</span></div><div class="line"></div><div class="line"><span class="comment"># 默认情况下, Git 执行 "快进式合并"(fast-farward merge), 使用 --no-ff 选项进行非快进式合并</span></div><div class="line">$ git merge --no-ff [branch-name]</div><div class="line"></div><div class="line"><span class="comment"># </span></div><div class="line">$ git rebase</div><div class="line"></div><div class="line"><span class="comment"># 选择一个(别的分支中的) commit, 合并到当前分支</span></div><div class="line">$ git cherry-pick [commit]</div></pre></td></tr></table></figure>
<h3 id="3-6-远程-fetch-remote-pull-push"><a href="#3-6-远程-fetch-remote-pull-push" class="headerlink" title="3.6 远程 fetch remote pull push"></a>3.6 远程 fetch remote pull push</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获取远程仓库的变动, 通常用来查看其他人的进程, 因为它取回的代码对你本地的开发代码没有影响, 取回的代码, 在本地主机上要用 "远程主机名/分支名" 的形式访问, 如 git reset --hard origin/master, git checkout -b dev-1 origin/master</span></div><div class="line"><span class="comment"># git fetch [remote-name] [remote-branch-name] + git merge [remote-name/remote-branch-name] = git pull [remote-name] [remote-branch-name]。所以一般不会直接使用 fetch</span></div><div class="line">$ git fetch [remote-name]</div><div class="line">$ git fetch [remote-name] [branch-name]</div><div class="line"></div><div class="line"><span class="comment"># 显示所有远程仓库, 带远程主机网址</span></div><div class="line">$ git remote -v</div><div class="line"></div><div class="line"><span class="comment"># 显示某个远程仓库的信息</span></div><div class="line">$ git remote show [remote-name]</div><div class="line"></div><div class="line"><span class="comment"># 将你的仓库连接到某个远程仓库, 并命名(clone 下来的远程仓库默认名字是 origin)</span></div><div class="line">$ git remote add [remote-name] [url]</div><div class="line"></div><div class="line"><span class="comment"># 远程仓库的重命名</span></div><div class="line">$ git remote rename [remote-name-old] [remote-name-new]</div><div class="line"></div><div class="line"><span class="comment"># 远程仓库的移除</span></div><div class="line">$ git remote rm [remote-name]</div><div class="line"></div><div class="line"><span class="comment"># 取回远程主机某个分支的更新并与本地分支合并, git pull = git fetch + git merge, 完整格式如下</span></div><div class="line">$ git pull [remote-name] [remote-branch-name]:[<span class="built_in">local</span>-branch-name]</div><div class="line"><span class="comment"># 与当前分支合并, 则冒号后面的部分可以省略</span></div><div class="line">$ git pull [remote-name] [remote-branch-name]</div><div class="line"><span class="comment"># 如果当前分支与远程分支存在追踪关系, git pull 就可以省略远程分支名</span></div><div class="line">$ git pull [remote-name]</div><div class="line"><span class="comment"># 如果当前分支只有一个追踪分支, 连远程主机名都可以省略</span></div><div class="line">$ git pull</div><div class="line"><span class="comment"># 如果合并需要采用 rebase 模式, 可以使用 --rebase 选项 = git fetch + git rebase</span></div><div class="line">$ git pull --rebase [remote-name] [remote-branch-name]:[<span class="built_in">local</span>-branch-name]</div><div class="line"></div><div class="line"><span class="comment"># 将本地分支的提交, 推送到远程主机, 完整格式如下, 注意与 pull 顺序不一样</span></div><div class="line">$ git push [remote-name] [<span class="built_in">local</span>-branch-name]:[remote-branch-name]</div><div class="line"><span class="comment"># 如果省略远程分支名, 则表示将本地分支推送与之存在 "追踪关系" 的远程分支(通常两者同名), 如果该远程分支不存在, 则会被新建</span></div><div class="line">$ git push [remote-name] [<span class="built_in">local</span>-branch-name]</div><div class="line"><span class="comment"># 如果省略本地分支名, 则表示删除指定的远程分支, 因为这等同于推送一个空的本地分支到远程分支。</span></div><div class="line">$ git push [remote-name] :[remote-branch-name]</div><div class="line"><span class="comment"># 等同于</span></div><div class="line">$ git push [remote-name] --delete [remote-branch-name]</div><div class="line"><span class="comment"># 如果当前分支与远程分支之间存在追踪关系, 则本地分支和远程分支都可以省略。</span></div><div class="line">$ git push [remote-name]</div><div class="line"><span class="comment"># 如果当前分支只有一个追踪分支, 那么主机名都可以省略。</span></div><div class="line">$ git push</div><div class="line"><span class="comment"># 如果当前分支与多个主机存在追踪关系, 则可以使用 -u 选项指定一个默认主机, 这样后面就可以不加任何参数使用 git push。</span></div><div class="line">$ git push -u [remote-name] [remote-branch-name]</div><div class="line"></div><div class="line"><span class="comment"># 强行推送当前分支到远程仓库, 即使有冲突(慎重!!)</span></div><div class="line">$ git push [remote-name] --force</div><div class="line"><span class="comment"># 用途: 撤销远程仓库的 commit 记录</span></div><div class="line">git reset --hard HEAD^</div><div class="line">git push -f</div><div class="line"></div><div class="line"><span class="comment"># 将本地的所有分支都推送到远程主机, 使用 --all 选项</span></div><div class="line">$ git push [remote-name] --all</div><div class="line"></div><div class="line"><span class="comment"># git push 不会推送标签(tag), 必须使用 --tags 选项单独推送标签</span></div><div class="line">$ git push [remote-name] --tags</div></pre></td></tr></table></figure>
<h3 id="3-7-查看信息-status-log-shortlog-diff-show-reflog-blame-bisect"><a href="#3-7-查看信息-status-log-shortlog-diff-show-reflog-blame-bisect" class="headerlink" title="3.7 查看信息 status log shortlog diff show reflog blame bisect"></a>3.7 查看信息 status log shortlog diff show reflog blame bisect</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 显示工作区和暂存区的状态</span></div><div class="line">$ git status</div><div class="line"></div><div class="line"><span class="comment"># 显示当前分支的版本历史</span></div><div class="line">$ git <span class="built_in">log</span></div><div class="line"></div><div class="line"><span class="comment"># 常用选项及其释义</span></div><div class="line"><span class="comment"># -&lt;n&gt;              显示最近 n 条提交</span></div><div class="line"><span class="comment"># --stat            显示每次更新的文件修改统计信息。</span></div><div class="line"><span class="comment"># --shortstat       只显示 --stat 中最后的行数修改添加移除统计。</span></div><div class="line"><span class="comment"># -p                按补丁格式显示每个更新之间的差异。</span></div><div class="line"><span class="comment"># --word-diff       按 word diff 格式显示差异。</span></div><div class="line"><span class="comment"># --name-only       仅在提交信息后显示已修改的文件清单。</span></div><div class="line"><span class="comment"># --name-status     显示新增、修改、删除的文件清单。</span></div><div class="line"><span class="comment"># --abbrev-commit   仅显示 SHA-1 的前几个字符, 而非所有的 40 个字符。</span></div><div class="line"><span class="comment"># --relative-date   使用较短的相对时间显示(比如, "2 weeks ago")。</span></div><div class="line"><span class="comment"># --pretty          使用其他格式显示历史提交信息。可用的选项包括 oneline, short, full, fuller 和 format(后跟指定格式)。</span></div><div class="line"><span class="comment"># --oneline         --pretty=oneline --abbrev-commit 的简化用法。</span></div><div class="line"><span class="comment"># --graph           显示 ASCII 图形表示的分支合并历史。</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># 还有一些用于筛选的选项, 见: https://git-scm.com/book/zh/v1/Git-基础-查看提交历史#限制输出长度</span></div><div class="line"><span class="comment"># --since, --after  仅显示指定时间之后的提交。</span></div><div class="line"><span class="comment"># --until, --before 仅显示指定时间之前的提交。</span></div><div class="line"><span class="comment"># --author          仅显示指定作者相关的提交。</span></div><div class="line"><span class="comment"># --committer       仅显示指定提交者相关的提交。</span></div><div class="line"></div><div class="line"><span class="comment"># gitk: git log 命令的可视化版本, 凡是 git log 可以用的选项也都能用在 gitk 上。在项目工作目录中输入 gitk 命令后, 即可启动</span></div><div class="line"></div><div class="line"><span class="comment"># 显示过去 5 次提交</span></div><div class="line">$ git <span class="built_in">log</span> -5</div><div class="line"></div><div class="line"><span class="comment"># 显示 commit 历史, 以及每次 commit 变更的简略统计信息</span></div><div class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span></div><div class="line"></div><div class="line"><span class="comment"># 使用不同于默认格式的方式展示提交历史 oneline short full fuller</span></div><div class="line">$ git <span class="built_in">log</span> --oneline <span class="comment"># 只有 oneline 可以这样用</span></div><div class="line">$ git <span class="built_in">log</span> --pretty=oneline</div><div class="line">$ git <span class="built_in">log</span> --pretty=short</div><div class="line">$ git <span class="built_in">log</span> --pretty=full</div><div class="line">$ git <span class="built_in">log</span> --pretty=fuller</div><div class="line"><span class="comment"># 还可以用 format 来定制要显示的记录格式, 便于后期编程提取分析, 见: https://git-scm.com/book/zh/v2/Git-基础-查看提交历史#pretty_format</span></div><div class="line"><span class="comment"># 用 oneline 或 format 时结合 --graph 选项, 可以看到用 ASCII 字符串表示的简单图形, 形象地展示了每个提交所在的分支及其分化衍合情况。例如</span></div><div class="line">$ git <span class="built_in">log</span> --pretty=format:<span class="string">"%h %s"</span> --graph</div><div class="line">* 2d3acf9 ignore errors from SIGCHLD on <span class="built_in">trap</span></div><div class="line">*  5e3ee11 Merge branch <span class="string">'master'</span> of git://github.com/dustin/grit</div><div class="line">|\</div><div class="line">| * 420eac9 Added a method <span class="keyword">for</span> getting the current branch.</div><div class="line">* | 30e367c timeout code and tests</div><div class="line">* | 5a09431 add timeout protection to grit</div><div class="line">* | e1193f8 support <span class="keyword">for</span> heads with slashes <span class="keyword">in</span> them</div><div class="line">|/</div><div class="line">* d6016bc require time <span class="keyword">for</span> xmlschema</div><div class="line">*  11d191e Merge branch <span class="string">'defunkt'</span> into <span class="built_in">local</span></div><div class="line"></div><div class="line"><span class="comment"># 显示每次提交的 diff</span></div><div class="line">$ git <span class="built_in">log</span> -p</div><div class="line"></div><div class="line"><span class="comment"># 显示指定文件每一次变更的 diff</span></div><div class="line">$ git <span class="built_in">log</span> -p [file]</div><div class="line"></div><div class="line"><span class="comment"># 显示某个用户的所有提交</span></div><div class="line">$ git <span class="built_in">log</span> --author=<span class="string">"username"</span></div><div class="line"><span class="comment"># 显示指定提交者相关的提交</span></div><div class="line">$ git <span class="built_in">log</span> --committer=<span class="string">"committername"</span></div><div class="line"><span class="comment"># since, after, until, before 用法一样</span></div><div class="line">$ git <span class="built_in">log</span> --since=<span class="string">"2008-10-01"</span>                  <span class="comment"># 2008-10-01 之后的提交</span></div><div class="line">$ git <span class="built_in">log</span> --since=2.weeks                       <span class="comment"># 近两周的提交</span></div><div class="line">$ git <span class="built_in">log</span> --since=<span class="string">"2 years 1 day 3 minutes ago"</span> <span class="comment"># 2 年 1 天 3 分钟之前 至 今 的提交</span></div><div class="line"></div><div class="line"><span class="comment"># 搜索提交历史, 根据关键词</span></div><div class="line">$ git <span class="built_in">log</span> -S [keyword]</div><div class="line"></div><div class="line"><span class="comment"># 显示某个 commit 之前的变动</span></div><div class="line">$ git <span class="built_in">log</span> [commit]</div><div class="line">$ git <span class="built_in">log</span> [commit] --pretty=format:<span class="string">"%h %s"</span></div><div class="line"></div><div class="line"><span class="comment"># 显示某个文件的版本历史, 包括文件改名</span></div><div class="line">$ git <span class="built_in">log</span> --follow [file]</div><div class="line">$ git whatchanged [file]</div><div class="line"></div><div class="line"><span class="comment"># git shortlog 是一种特殊的 git log, 它是为创建发布声明设计的。它把每个提交按作者分类, 显示提交信息的第一行。这样可以容易地看到谁做了什么。默认情况下按作者名字排序, 但你可以传入 -n 选项来按每个作者提交数量排序。-s 选项不显示提交描述, 只显示提交数</span></div><div class="line">$ git shortlog -sn</div><div class="line"></div><div class="line"><span class="comment"># 显示暂存区和工作区 (已追踪文件) 的差异</span></div><div class="line">$ git diff</div><div class="line"></div><div class="line"><span class="comment"># 显示暂存区与当前分支最新 commit 之间的差异</span></div><div class="line">$ git diff --staged</div><div class="line">$ git diff --staged [file]</div><div class="line"></div><div class="line"><span class="comment"># 显示工作区与当前分支最新 commit 之间的差异</span></div><div class="line">$ git diff HEAD</div><div class="line"></div><div class="line"><span class="comment"># 显示两个分支 (的最新版本) 之间的差异</span></div><div class="line">$ git diff [first-branch] [second-branch]</div><div class="line"></div><div class="line"><span class="comment"># 显示两个 commit 之间的差异</span></div><div class="line">$ git diff [first-commit-id] [second-commit-id]</div><div class="line"></div><div class="line"><span class="comment"># "git diff A...B" is equivalent to "git diff $(git-merge-base A B) B". 展示从 A B 最近共同祖先到 B 的 diff</span></div><div class="line">$ git diff [first-commit-id]...[second-commit-id]</div><div class="line"></div><div class="line"><span class="comment"># 显示今天你写了多少行代码</span></div><div class="line">$ git diff --shortstat <span class="string">"@&#123;0 day ago&#125;"</span></div><div class="line"></div><div class="line"><span class="comment"># 显示某次提交的元数据和内容变化</span></div><div class="line">$ git show [commit]</div><div class="line"></div><div class="line"><span class="comment"># 显示某次提交发生变化的文件</span></div><div class="line">$ git show --name-only [commit]</div><div class="line"></div><div class="line"><span class="comment"># 显示某次提交时, 某个文件的内容</span></div><div class="line">$ git show [commit]:[filename]</div><div class="line"></div><div class="line"><span class="comment"># 如不小心用 git commit --amend 当成 git commit 覆盖当前的 commit, 或不小心把当前的 commit 给搞没了(reset --hard), 可以通过引用日志 reflog 命令来了解你对 HEAD 值的改变(或用 git log -g 以标准日志的格式输出引用日志), 然后通过 git reset 命令进行恢复</span></div><div class="line">$ git reflog</div><div class="line"></div><div class="line"><span class="comment"># blame 和 bisect 命令参见: https://git-scm.com/book/zh/v2/Git-工具-使用-Git-调试</span></div><div class="line"><span class="comment"># 显示 指定文件的各部分 最后一次修改的信息: 什么人在什么时间修改过</span></div><div class="line">$ git blame [file]</div></pre></td></tr></table></figure>
<h3 id="3-8-撤销-checkout-reset-revert-clean-stash"><a href="#3-8-撤销-checkout-reset-revert-clean-stash" class="headerlink" title="3.8 撤销 checkout reset revert clean stash"></a>3.8 撤销 checkout reset revert clean stash</h3><p><strong>常用 checkout 来撤销未暂存的修改, reset HEAD 来撤销没有提交的更改, revert 来撤销已经提交的更改。</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1. git reset 将一个分支的 HEAD 指针指向另一个提交, 这可以用来移除当前分支的一些提交。下次 Git 执行垃圾回收 (很久很久一次) 的时候, 这两个提交会被删除(在此之前用 git reflog 找到丢掉的 commit id, 再用 git reset 可以还原回来)。换句话说, 如果你想扔掉这两个提交, 就用 git reset。除了在当前分支上操作, 你还可以通过传入这些标记来修改你的缓存区或工作目录</span></div><div class="line"><span class="comment"># --soft  缓存区和工作目录都不会被改变</span></div><div class="line"><span class="comment"># --mixed 默认选项。缓存区和你指定的提交同步, 但工作目录不受影响</span></div><div class="line"><span class="comment"># --hard  缓存区和工作目录都同步到你指定的提交</span></div><div class="line"></div><div class="line"><span class="comment"># 2. git checkout 与 git reset 类似, 但除了 `git checkout [file]` 和 `git checkout .` 外不推荐使用 checkout 来做撤销, checkout 用于分支切换比较好</span></div><div class="line"></div><div class="line"><span class="comment"># 注: git reset 和 git checkout 命令也接受文件路径作为参数。这时它的行为就大为不同了。它不会作用于整份提交, 参数将它限制于特定文件。--soft 和 --hard 对文件层面的 reset 毫无作用, 因为缓存区中的文件一定会变化, 而工作目录中的文件一定不变(即 --mixed)。</span></div><div class="line"></div><div class="line"><span class="comment"># 3. git revert 通过创建一个新的提交来抵消一个提交的更改。这是一个安全的方法, 因为它不会重写提交历史。因此, revert 可以用在公共分支上, reset 应该用在私有分支上。</span></div><div class="line"></div><div class="line"><span class="comment"># 恢复暂存区的指定文件到工作区(常用)</span></div><div class="line">$ git checkout [file]</div><div class="line"></div><div class="line"><span class="comment"># 恢复暂存区的所有文件到工作区(常用)</span></div><div class="line">$ git checkout .</div><div class="line"></div><div class="line"><span class="comment"># 恢复某个 commit 的所有文件到暂存区和工作区</span></div><div class="line">$ git checkout [commit]</div><div class="line"></div><div class="line"><span class="comment"># 恢复某个 commit 的指定文件到暂存区和工作区</span></div><div class="line">$ git checkout [commit] [file]</div><div class="line"></div><div class="line"><span class="comment"># 重置暂存区的指定文件, 与上一次 commit 保持一致, 但工作区不变</span></div><div class="line">$ git reset [file]</div><div class="line"></div><div class="line"><span class="comment"># 重置当前分支的 HEAD 指针为指定 commit, 同时重置暂存区, 但工作区不变</span></div><div class="line">$ git reset [commit]</div><div class="line"></div><div class="line"><span class="comment"># 重置暂存区与工作区, 与上一次 commit 保持一致(常用)</span></div><div class="line">$ git reset --hard</div><div class="line"></div><div class="line"><span class="comment"># 重置当前分支的 HEAD 指针为指定 commit, 同时重置暂存区和工作区与指定 commit 一致(常用)</span></div><div class="line">$ git reset --hard [commit]</div><div class="line"></div><div class="line"><span class="comment"># 重置当前 HEAD 为指定 commit, 但保持暂存区和工作区不变(常用)</span></div><div class="line">$ git reset --keep [commit]</div><div class="line"></div><div class="line"><span class="comment"># 新建一个 commit, 用来撤销指定 commit, 后者的所有变化都将被前者抵消, 并且应用到当前分支(常用)</span></div><div class="line">$ git revert [commit]</div><div class="line"></div><div class="line"><span class="comment"># git clean 命令用来从你的工作目录中删除所有没有 tracked 过的文件。git clean 经常和 git reset --hard 一起结合使用, 因为 reset 只影响被 track 过的文件, 所以需要 clean 来删除没有 track 过的文件, 结合使用这两个命令能让你的工作目录完全回到一个指定的 [commit] 的状态。git clean 对于刚编译过的项目也非常有用。如, 他能轻易删除掉编译后生成的.o 和.exe 等文件。这个在打包要发布一个 release 的时候非常有用。</span></div><div class="line"><span class="comment"># -n 选项是一次 clean 的演习, 告诉你哪些文件会被删除。记住他不会真正的删除文件, 只是一个提醒</span></div><div class="line">$ git clean -n</div><div class="line"><span class="comment"># 删除当前目录下所有没有 track 过的文件。他不会删除 .gitignore 文件里面指定的文件夹和文件, 不管这些文件有没有被 track 过</span></div><div class="line">git clean -f</div><div class="line"><span class="comment"># 删除指定路径下的没有被 track 过的文件</span></div><div class="line">git clean -f &lt;path&gt;</div><div class="line"><span class="comment"># 删除当前目录下没有被 track 过的文件和文件夹</span></div><div class="line">git clean -df</div><div class="line"></div><div class="line"><span class="comment"># 当你的工作区不 clean, 而你想转到其他分支上进行一些工作, 却不想提交进行了一半的工作, 可以用 git stash 命令, 它命令可以把当前工作现场 "储藏" 起来, 等以后恢复现场后继续工作。使用 git stash 命令后再用 git status 查看工作区, 就是 clean 的, 可以方便地切换到其他分支工作, 而你的变更都保存在栈上。甚至可以在其中一个分支上保留一份储藏, 切换到另外一个分支, 再重新应用这些变更(有点像 rebase)。</span></div><div class="line">$ git stash</div><div class="line"><span class="comment"># 可以加上信息</span></div><div class="line">$ git stash save <span class="string">"message..."</span></div><div class="line"><span class="comment"># 查看现有的储藏</span></div><div class="line">$ git stash list</div><div class="line"><span class="comment"># 重新应用你刚刚实施的储藏</span></div><div class="line">$ git stash apply</div><div class="line"><span class="comment"># 应用更早的储藏, 你可以通过名字指定它, 如果你不指明, Git 默认使用最近的储藏并尝试应用它</span></div><div class="line">$ git stash apply stash@&#123;0&#125;</div><div class="line"><span class="comment"># apply 选项只尝试应用储藏的工作 --- 储藏的内容仍然在栈上。要移除它, 你可以运行 git stash drop, 加上你希望移除的储藏的名字</span></div><div class="line">$ git stash drop stash@&#123;0&#125;</div><div class="line"><span class="comment"># 可以运行 git stash pop 来重新应用储藏, 同时立刻将其从堆栈中移走</span></div><div class="line">$ git stash pop</div><div class="line"><span class="comment"># 清空储藏栈</span></div><div class="line">$ git stash clear</div></pre></td></tr></table></figure>
<h3 id="3-9-标签-tag"><a href="#3-9-标签-tag" class="headerlink" title="3.9 标签 tag"></a>3.9 标签 tag</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 列出所有 tag</span></div><div class="line">$ git tag</div><div class="line"></div><div class="line"><span class="comment"># 新建一个 tag 在当前 commit</span></div><div class="line">$ git tag [tag]</div><div class="line"></div><div class="line"><span class="comment"># 新建一个 tag 在指定 commit</span></div><div class="line">$ git tag [tag] [commit]</div><div class="line"></div><div class="line"><span class="comment"># 删除本地 tag</span></div><div class="line">$ git tag -d [tag]</div><div class="line"></div><div class="line"><span class="comment"># 删除远程 tag</span></div><div class="line">$ git push origin :refs/tags/[tagName]</div><div class="line"></div><div class="line"><span class="comment"># 查看 tag 信息</span></div><div class="line">$ git show [tag]</div><div class="line"></div><div class="line"><span class="comment"># 提交指定 tag</span></div><div class="line">$ git push [remote-name] [tag]</div><div class="line"></div><div class="line"><span class="comment"># 提交(包含 tag)</span></div><div class="line">$ git push [remote-name] --tags</div><div class="line"></div><div class="line"><span class="comment"># 新建一个分支, 指向某个 tag</span></div><div class="line">$ git checkout -b [branch-name] [tag]</div></pre></td></tr></table></figure>
<h3 id="3-10-其他"><a href="#3-10-其他" class="headerlink" title="3.10 其他"></a>3.10 其他</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 生成一个可供发布的压缩包</span></div><div class="line">$ git archive</div></pre></td></tr></table></figure>
<h2 id="4-高级技巧"><a href="#4-高级技巧" class="headerlink" title="4 高级技巧"></a>4 高级技巧</h2><h3 id="4-1-修改作者时间-提交时间"><a href="#4-1-修改作者时间-提交时间" class="headerlink" title="4.1 修改作者时间 / 提交时间"></a>4.1 修改作者时间 / 提交时间</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 设置作者时间, PS: 很奇怪的一个问题, 月日必须反过来, date -d "Jun 8 14:00 2017" 都不行, 提交后在 Git 上是 Aug 6</span></div><div class="line">$ git commit --date=<span class="string">"`date -d "</span>2017-08-06 16:21:45<span class="string">"`"</span> -m [message]</div><div class="line"></div><div class="line"><span class="comment"># 设置提交时间及作者时间(时间问题同上) --- !!!</span></div><div class="line">GIT_COMMITTER_DATE=<span class="string">"`date -d "</span>2017-08-06 16:21:45<span class="string">"`"</span> git commit --date=<span class="string">"`date -d "</span>2017-08-06 16:21:45<span class="string">"`"</span> -m [message]</div><div class="line"></div><div class="line"><span class="comment"># 事后修改时间(时间问题同上) -- 记得把被重写的 commit 彻底删掉 --- !!!</span></div><div class="line">GIT_COMMITTER_DATE=<span class="string">"`date -d "</span>2017-08-06 16:21:45<span class="string">"`"</span> git commit --amend --date=<span class="string">"`date -d "</span>2017-08-06 16:21:45<span class="string">"`"</span> -m [message]</div><div class="line">git reflog</div><div class="line">git reflog delete HEAD@&#123;1&#125; <span class="comment"># HEAD@&#123;1&#125;是那个想要删除的 ref</span></div></pre></td></tr></table></figure>
<h3 id="4-2-数据清理与数据维护"><a href="#4-2-数据清理与数据维护" class="headerlink" title="4.2 数据清理与数据维护"></a>4.2 数据清理与数据维护</h3><p><a href="https://git-scm.com/book/zh/v1/Git-内部原理-维护及数据恢复" target="_blank" rel="external">https://git-scm.com/book/zh/v1/Git-内部原理-维护及数据恢复</a></p>
<h3 id="4-3-GitHub-技巧"><a href="#4-3-GitHub-技巧" class="headerlink" title="4.3 GitHub 技巧"></a>4.3 GitHub 技巧</h3><p>在 GitHub 网页任意界面, 按 Shift + / 显示当前可用快捷键。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://git-scm.com/docs" target="_blank" rel="external">Git 官方英文文档</a></li>
<li><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="external">Pro Git 简体中文版</a></li>
<li><a href="https://www.git-tower.com/learn/git/ebook/cn/command-line/introduction" target="_blank" rel="external">Tower 的中文 git 教程</a></li>
<li><a href="http://blog.jobbole.com/87410" target="_blank" rel="external">Git 版本控制与工作流</a></li>
<li><a href="http://blog.jobbole.com/81196" target="_blank" rel="external">一个成功的 Git 分支模型</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="external">常用 Git 命令清单</a></li>
<li><a href="https://github.com/geeeeeeeeek/git-recipes/wiki" target="_blank" rel="external">高质量的 Git 中文教程</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章是针对 &lt;strong&gt;Git Flow &amp;amp; Git 命令&lt;/strong&gt; 的 &lt;strong&gt;总结&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我花费了很大精力才完成的！&lt;/p&gt;
    
    </summary>
    
      <category term="版本管理" scheme="http://blog.lyogvce.me/categories/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    
      <category term="Git" scheme="http://blog.lyogvce.me/categories/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/Git/"/>
    
    
      <category term="Git" scheme="http://blog.lyogvce.me/tags/Git/"/>
    
      <category term="Git flow" scheme="http://blog.lyogvce.me/tags/Git-flow/"/>
    
  </entry>
  
  <entry>
    <title>TimSort</title>
    <link href="http://blog.lyogvce.me/2017-04/TimSort.html"/>
    <id>http://blog.lyogvce.me/2017-04/TimSort.html</id>
    <published>2017-04-26T16:00:00.000Z</published>
    <updated>2017-07-16T02:27:01.557Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p>
<ul>
<li><a href="http://www.freebuf.com/vuls/62129.html" target="_blank" rel="external">http://www.freebuf.com/vuls/62129.html</a></li>
<li><a href="http://blog.csdn.net/yangzhongblog/article/details/8184707" target="_blank" rel="external">http://blog.csdn.net/yangzhongblog/article/details/8184707</a></li>
</ul>
<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>Timsort 是结合了合并排序 (merge sort) 和插入排序 (insertion sort) 而得出的排序算法, Tim Peters 在 2002 年 (相比其他排序算法算是后起之秀) 设计了该算法并在 Python 中使用(TimSort 是 Python 中 list.sort 的默认实现), 现在 Java SE7 和 Android 也采用 Timsort 算法对数组排序。</p>
<a id="more"></a>
<p>我们评价一个排序算法的好坏要从许多方面衡量, 如下面这张图, 它在现实中有很好的效率。快排虽然平均时间复杂度非常好, 但是在最优、最坏时间复杂度以及算法的稳定性上来说都不如 Timsort。</p>
<p><img src="../images/TimSort/Compare.png" alt="算法比较">算法比较</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.freebuf.com/vuls/62129.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.freebuf.com/vuls/62129.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/yangzhongblog/article/details/8184707&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/yangzhongblog/article/details/8184707&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1&quot;&gt;&lt;a href=&quot;#1&quot; class=&quot;headerlink&quot; title=&quot;1&quot;&gt;&lt;/a&gt;1&lt;/h2&gt;&lt;p&gt;Timsort 是结合了合并排序 (merge sort) 和插入排序 (insertion sort) 而得出的排序算法, Tim Peters 在 2002 年 (相比其他排序算法算是后起之秀) 设计了该算法并在 Python 中使用(TimSort 是 Python 中 list.sort 的默认实现), 现在 Java SE7 和 Android 也采用 Timsort 算法对数组排序。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://blog.lyogvce.me/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://blog.lyogvce.me/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://blog.lyogvce.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://blog.lyogvce.me/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 新特性探究 之 深入解析日期和时间 - JSR310</title>
    <link href="http://blog.lyogvce.me/2017-04/Date-And-Time-Of-Java.html"/>
    <id>http://blog.lyogvce.me/2017-04/Date-And-Time-Of-Java.html</id>
    <published>2017-04-01T16:00:00.000Z</published>
    <updated>2017-07-16T02:27:01.049Z</updated>
    
    <content type="html"><![CDATA[<p>转自: <a href="https://my.oschina.net/benhaile/blog/193956" target="_blank" rel="external">https://my.oschina.net/benhaile/blog/193956</a></p>
<p>摘要: JSR310 已在 java8 中实现了, 对于恶心的 java.util.Date 和 Calendar, 终于可以休息了吧。。。</p>
<p>这次给大家讲下 java8 时间与日期 API。</p>
<p>众所周知, 日期是商业逻辑计算一个关键的部分, 任何企业应用程序都需要处理时间问题。应用程序需要知道当前的时间点和下一个时间点, 有时它们还必须计算这两个时间点之间的路径。但 java 之前的日期做法太令人恶心了, 我们先来吐槽一下</p>
<a id="more"></a>
<h2 id="吐槽-java-util-Date-跟-Calendar"><a href="#吐槽-java-util-Date-跟-Calendar" class="headerlink" title="吐槽 java.util.Date 跟 Calendar"></a>吐槽 java.util.Date 跟 Calendar</h2><p>Tiago Fernandez 做过一次投票, 选举最烂的 JAVA API, 排第一的 EJB2.X, 第二的就是日期 API。</p>
<h3 id="槽点一"><a href="#槽点一" class="headerlink" title="槽点一"></a>槽点一</h3><p>最开始的时候, Date 既要承载日期信息, 又要做日期之间的转换, 还要做不同日期格式的显示, 职责较繁杂(不懂单一职责, 你妈妈知道吗？纯属恶搞~ 哈哈)</p>
<p>后来从 JDK 1.1 开始, 这三项职责分开了:</p>
<ul>
<li>使用 Calendar 类实现日期和时间字段之间转换;</li>
<li>使用 DateFormat 类来格式化和分析日期字符串;</li>
<li>而 Date 只用来承载日期和时间信息。</li>
</ul>
<p>原有 Date 中的相应方法已废弃。不过, 无论是 Date, 还是 Calendar, 都用着太不方便了, 这是 API 没有设计好的地方。</p>
<h3 id="槽点二"><a href="#槽点二" class="headerlink" title="槽点二"></a>槽点二</h3><p>坑爹的 year 和 month</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Date date = <span class="keyword">new</span> Date(<span class="number">2012</span>,<span class="number">1</span>,<span class="number">1</span>);</div><div class="line">System.out.println(date);</div><div class="line"><span class="comment">// 输出 Thu Feb 01 00:00:00 CST 3912</span></div></pre></td></tr></table></figure>
<p>观察输出结果, year 是 2012+1900, 而 month, 月份参数我不是给了 1 吗？怎么输出二月 (Feb) 了？</p>
<p>应该曾有人告诉你, 如果你要设置日期, 应该使用 java.util.Calendar, 像这样…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Calendar calendar = Calendar.getInstance();</div><div class="line">calendar.set(<span class="number">2013</span>, <span class="number">8</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>这样写又不对了, calendar 的 month 也是从 0 开始的, 表达 8 月份应该用 7 这个数字, 要么就干脆用枚举</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">calendar.set(<span class="number">2013</span>, Calendar.AUGUST, <span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>注意上面的代码, Calendar 年份的传值不需要减去 1900(当然月份的定义和 Date 还是一样), 这种不一致真是让人抓狂！</p>
<p>有些人可能知道, Calendar 相关的 API 是 IBM 捐出去的, 所以才导致不一致。</p>
<h3 id="槽点三"><a href="#槽点三" class="headerlink" title="槽点三"></a>槽点三</h3><p>java.util.Date 与 java.util.Calendar 中的所有属性都是可变的</p>
<p>下面的代码, 计算两个日期之间的天数….</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Calendar birth = Calendar.getInstance();</div><div class="line">    birth.set(<span class="number">1975</span>, Calendar.MAY, <span class="number">26</span>);</div><div class="line">    Calendar now = Calendar.getInstance();</div><div class="line">    System.out.println(daysBetween(birth, now));</div><div class="line">    System.out.println(daysBetween(birth, now)); <span class="comment">// 显示 0？</span></div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">daysBetween</span><span class="params">(Calendar begin, Calendar end)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> daysBetween = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(begin.before(end)) &#123;</div><div class="line">        begin.add(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</div><div class="line">        daysBetween++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> daysBetween;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>daysBetween 有点问题, 如果连续计算两个 Date 实例的话, 第二次会取得 0, 因为 Calendar 状态是可变的, 考虑到重复计算的场合, 最好复制一个新的 Calendar</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">daysBetween</span><span class="params">(Calendar begin, Calendar end)</span> </span>&#123;</div><div class="line">    Calendar calendar = (Calendar) begin.clone(); <span class="comment">// 复制</span></div><div class="line">    <span class="keyword">long</span> daysBetween = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(calendar.before(end)) &#123;</div><div class="line">        calendar.add(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</div><div class="line">        daysBetween++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> daysBetween;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="JSR310"><a href="#JSR310" class="headerlink" title="JSR310"></a>JSR310</h2><p>以上种种, 导致目前有些第三方的 java 日期库诞生, 比如广泛使用的 JODA-TIME, 还有 Date4j 等, 虽然第三方库已经足够强大, 好用, 但还是有兼容问题的, 比如标准的 JSF 日期转换器与 joda-time API 就不兼容, 你需要编写自己的转换器, 所以标准的 API 还是必须的, 于是就有了 JSR310。</p>
<p>JSR 310 实际上有两个日期概念。第一个是 Instant, 它大致对应于 java.util.Date 类, 因为它代表了一个确定的时间点, 即相对于标准 Java 纪元 (1970 年 1 月 1 日) 的偏移量; 但与 java.util.Date 类不同的是其精确到了纳秒级别。</p>
<p>第二个对应于人类自身的观念, 比如 LocalDate 和 LocalTime。他们代表了一般的时区概念, 要么是日期(不包含时间), 要么是时间(不包含日期), 类似于 java.sql 的表示方式。此外, 还有一个 MonthDay, 它可以存储某人的生日(不包含年份)。每个类都在内部存储正确的数据而不是像 java.util.Date 那样利用午夜 12 点来区分日期, 利用 1970-01-01 来表示时间。</p>
<p>目前 Java8 已经实现了 JSR310 的全部内容。新增了 java.time 包定义的类表示了日期 - 时间概念的规则, 包括 instants, durations, dates, times, time-zones and periods。这些都是基于 ISO 日历系统, 它又是遵循 Gregorian 规则的。最重要的一点是值不可变, 且线程安全, 通过下面一张图, 我们快速看下 <a href="http://download.java.net/jdk8/docs/api/index.html?java/time/package-summary.html" target="_blank" rel="external">java.time</a> 包下的一些主要的类的值的格式, 方便理解。</p>
<p><img src="../images/Date-And-Time-Of-Java/1.jpg" alt="img"></p>
<h3 id="方法概览"><a href="#方法概览" class="headerlink" title="方法概览"></a>方法概览</h3><p>该包的 API 提供了大量相关的方法, 这些方法一般有一致的方法前缀:</p>
<ul>
<li>of: 静态工厂方法。</li>
<li>parse: 静态工厂方法, 关注于解析。</li>
<li>get: 获取某些东西的值。</li>
<li>is: 检查某些东西的是否是 true。</li>
<li>with: 不可变的 setter 等价物。</li>
<li>plus: 加一些量到某个对象。</li>
<li>minus: 从某个对象减去一些量。</li>
<li>to: 转换到另一个类型。</li>
<li>at: 把这个对象与另一个对象组合起来, 例如: date.atTime(time)。</li>
</ul>
<h3 id="与旧的-API-对应关系"><a href="#与旧的-API-对应关系" class="headerlink" title="与旧的 API 对应关系"></a>与旧的 API 对应关系</h3><p><img src="../images/Date-And-Time-Of-Java/2.png" alt="img"></p>
<h3 id="简单使用-java-time-的-API"><a href="#简单使用-java-time-的-API" class="headerlink" title="简单使用 java.time 的 API"></a>简单使用 java.time 的 API</h3><p>参考 <a href="http://jinnianshilongnian.iteye.com/blog/1994164" target="_blank" rel="external">http://jinnianshilongnian.iteye.com/blog/1994164</a>, 被我揉在一起, 可读性很差, 相应的代码都有注释了, 我就不过多解释了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeIntroduction</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testClock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="comment">// 时钟提供给我们用于访问某个特定 时区的 瞬时时间、日期 和 时间的。</span></div><div class="line">        Clock c1 = Clock.systemUTC(); <span class="comment">// 系统默认 UTC 时钟(当前瞬时时间 System.currentTimeMillis())</span></div><div class="line">        System.out.println(c1.millis()); <span class="comment">// 每次调用将返回当前瞬时时间(UTC)</span></div><div class="line">        Clock c2 = Clock.systemDefaultZone(); <span class="comment">// 系统默认时区时钟(当前瞬时时间)</span></div><div class="line">        Clock c31 = Clock.system(ZoneId.of(<span class="string">"Europe/Paris"</span>)); <span class="comment">// 巴黎时区</span></div><div class="line">        System.out.println(c31.millis()); <span class="comment">// 每次调用将返回当前瞬时时间(UTC)</span></div><div class="line">        Clock c32 = Clock.system(ZoneId.of(<span class="string">"Asia/Shanghai"</span>));<span class="comment">// 上海时区</span></div><div class="line">        System.out.println(c32.millis());<span class="comment">// 每次调用将返回当前瞬时时间(UTC)</span></div><div class="line">        Clock c4 = Clock.fixed(Instant.now(), ZoneId.of(<span class="string">"Asia/Shanghai"</span>));<span class="comment">// 固定上海时区时钟</span></div><div class="line">        System.out.println(c4.millis());</div><div class="line">        Thread.sleep(<span class="number">1000</span>);</div><div class="line">        System.out.println(c4.millis()); <span class="comment">// 不变 即时钟时钟在那一个点不动</span></div><div class="line">        Clock c5 = Clock.offset(c1, Duration.ofSeconds(<span class="number">2</span>)); <span class="comment">// 相对于系统默认时钟两秒的时钟</span></div><div class="line">        System.out.println(c1.millis());</div><div class="line">        System.out.println(c5.millis());</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testInstant</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 瞬时时间 相当于以前的 System.currentTimeMillis()</span></div><div class="line">        Instant instant1 = Instant.now();</div><div class="line">        System.out.println(instant1.getEpochSecond());<span class="comment">// 精确到秒 得到相对于 1970-01-01 00:00:00 UTC 的一个时间</span></div><div class="line">        System.out.println(instant1.toEpochMilli()); <span class="comment">// 精确到毫秒</span></div><div class="line">        Clock clock1 = Clock.systemUTC(); <span class="comment">// 获取系统 UTC 默认时钟</span></div><div class="line">        Instant instant2 = Instant.now(clock1);<span class="comment">// 得到时钟的瞬时时间</span></div><div class="line">        System.out.println(instant2.toEpochMilli());</div><div class="line">        Clock clock2 = Clock.fixed(instant1, ZoneId.systemDefault()); <span class="comment">// 固定瞬时时间时钟</span></div><div class="line">        Instant instant3 = Instant.now(clock2);<span class="comment">// 得到时钟的瞬时时间</span></div><div class="line">        System.out.println(instant3.toEpochMilli());<span class="comment">//equals instant1</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testLocalDateTime</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 使用默认时区时钟瞬时时间创建 Clock.systemDefaultZone() --&gt; 即相对于 ZoneId.systemDefault()默认时区</span></div><div class="line">        LocalDateTime now = LocalDateTime.now();</div><div class="line">        System.out.println(now);</div><div class="line">        <span class="comment">// 自定义时区</span></div><div class="line">        LocalDateTime now2 = LocalDateTime.now(ZoneId.of(<span class="string">"Europe/Paris"</span>));</div><div class="line">        System.out.println(now2);<span class="comment">// 会以相应的时区显示日期</span></div><div class="line">        <span class="comment">// 自定义时钟</span></div><div class="line">        Clock clock = Clock.system(ZoneId.of(<span class="string">"Asia/Dhaka"</span>));</div><div class="line">        LocalDateTime now3 = LocalDateTime.now(clock);</div><div class="line">        System.out.println(now3);<span class="comment">// 会以相应的时区显示日期</span></div><div class="line">        <span class="comment">// 不需要写什么相对时间 如 java.util.Date 年是相对于 1900 月是从 0 开始</span></div><div class="line">        <span class="comment">//2013-12-31 23:59</span></div><div class="line">        LocalDateTime d1 = LocalDateTime.of(<span class="number">2013</span>, <span class="number">12</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>);</div><div class="line">        <span class="comment">// 年月日 时分秒 纳秒</span></div><div class="line">        LocalDateTime d2 = LocalDateTime.of(<span class="number">2013</span>, <span class="number">12</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">11</span>);</div><div class="line">        <span class="comment">// 使用瞬时时间 + 时区</span></div><div class="line">        Instant instant = Instant.now();</div><div class="line">        LocalDateTime d3 = LocalDateTime.ofInstant(Instant.now(), ZoneId.systemDefault());</div><div class="line">        System.out.println(d3);</div><div class="line">        <span class="comment">// 解析 String---&gt;LocalDateTime</span></div><div class="line">        LocalDateTime d4 = LocalDateTime.parse(<span class="string">"2013-12-31T23:59"</span>);</div><div class="line">        System.out.println(d4);</div><div class="line">        LocalDateTime d5 = LocalDateTime.parse(<span class="string">"2013-12-31T23:59:59.999"</span>);<span class="comment">// 999 毫秒 等价于 999000000 纳秒</span></div><div class="line">        System.out.println(d5);</div><div class="line">        <span class="comment">// 使用 DateTimeFormatter API 解析 和 格式化</span></div><div class="line">        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy/MM/dd HH:mm:ss"</span>);</div><div class="line">        LocalDateTime d6 = LocalDateTime.parse(<span class="string">"2013/12/31 23:59:59"</span>, formatter);</div><div class="line">        System.out.println(formatter.format(d6));</div><div class="line">        <span class="comment">// 时间获取</span></div><div class="line">        System.out.println(d6.getYear());</div><div class="line">        System.out.println(d6.getMonth());</div><div class="line">        System.out.println(d6.getDayOfYear());</div><div class="line">        System.out.println(d6.getDayOfMonth());</div><div class="line">        System.out.println(d6.getDayOfWeek());</div><div class="line">        System.out.println(d6.getHour());</div><div class="line">        System.out.println(d6.getMinute());</div><div class="line">        System.out.println(d6.getSecond());</div><div class="line">        System.out.println(d6.getNano());</div><div class="line">        <span class="comment">// 时间增减</span></div><div class="line">        LocalDateTime d7 = d6.minusDays(<span class="number">1</span>);</div><div class="line">        LocalDateTime d8 = d7.plus(<span class="number">1</span>, IsoFields.QUARTER_YEARS);</div><div class="line">        <span class="comment">// LocalDate 即年月日 无时分秒</span></div><div class="line">        <span class="comment">// LocalTime 即时分秒 无年月日</span></div><div class="line">        <span class="comment">// API 和 LocalDateTime 类似就不演示了</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testZonedDateTime</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 即带有时区的 date-time 存储纳秒、时区和时差(避免与本地 date-time 歧义)。</span></div><div class="line">        <span class="comment">// API 和 LocalDateTime 类似, 只是多了时差(如 2013-12-20T10:35:50.711+08:00[Asia/Shanghai])</span></div><div class="line">        ZonedDateTime now = ZonedDateTime.now();</div><div class="line">        System.out.println(now);</div><div class="line">        ZonedDateTime now2 = ZonedDateTime.now(ZoneId.of(<span class="string">"Europe/Paris"</span>));</div><div class="line">        System.out.println(now2);</div><div class="line">        <span class="comment">// 其他的用法也是类似的 就不介绍了</span></div><div class="line">        ZonedDateTime z1 = ZonedDateTime.parse(<span class="string">"2013-12-31T23:59:59Z[Europe/Paris]"</span>);</div><div class="line">        System.out.println(z1);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testDuration</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 表示两个瞬时时间的时间段</span></div><div class="line">        Duration d1 = Duration.between(Instant.ofEpochMilli(System.currentTimeMillis() - <span class="number">12323123</span>), Instant.now());</div><div class="line">        <span class="comment">// 得到相应的时差</span></div><div class="line">        System.out.println(d1.toDays());</div><div class="line">        System.out.println(d1.toHours());</div><div class="line">        System.out.println(d1.toMinutes());</div><div class="line">        System.out.println(d1.toMillis());</div><div class="line">        System.out.println(d1.toNanos());</div><div class="line">        <span class="comment">// 1 天时差 类似的还有如 ofHours()</span></div><div class="line">        Duration d2 = Duration.ofDays(<span class="number">1</span>);</div><div class="line">        System.out.println(d2.toDays());</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testChronology</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 提供对 java.util.Calendar 的替换, 提供对年历系统的支持</span></div><div class="line">        Chronology c = HijrahChronology.INSTANCE;</div><div class="line">        ChronoLocalDateTime d = c.localDateTime(LocalDateTime.now());</div><div class="line">        System.out.println(d);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 新旧日期转换</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testNewOldDateConversion</span><span class="params">()</span></span>&#123;</div><div class="line">        Instant instant=<span class="keyword">new</span> Date().toInstant();</div><div class="line">        Date date=Date.from(instant);</div><div class="line">        System.out.println(instant);</div><div class="line">        System.out.println(date);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        testClock();</div><div class="line">        testInstant();</div><div class="line">        testLocalDateTime();</div><div class="line">        testZonedDateTime();</div><div class="line">        testDuration();</div><div class="line">        testChronology();</div><div class="line">        testNewOldDateConversion();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 取本月第 1 天:</span></div><div class="line">LocalDate firstDayOfThisMonth = today.with(TemporalAdjusters.firstDayOfMonth()); <span class="comment">// 2014-12-01</span></div><div class="line"><span class="comment">// 取本月第 2 天:</span></div><div class="line">LocalDate secondDayOfThisMonth = today.withDayOfMonth(<span class="number">2</span>); <span class="comment">// 2014-12-02</span></div><div class="line"><span class="comment">// 取本月最后一天, 再也不用计算是 28, 29, 30 还是 31:</span></div><div class="line">LocalDate lastDayOfThisMonth = today.with(TemporalAdjusters.lastDayOfMonth()); <span class="comment">// 2014-12-31</span></div><div class="line"><span class="comment">// 取下一天:</span></div><div class="line">LocalDate firstDayOf2015 = lastDayOfThisMonth.plusDays(<span class="number">1</span>); <span class="comment">// 变成了 2015-01-01</span></div><div class="line"><span class="comment">// 取 2015 年 1 月第一个周一, 这个计算用 Calendar 要死掉很多脑细胞:</span></div><div class="line">LocalDate firstMondayOf2015 = LocalDate.parse(<span class="string">"2015-01-01"</span>).with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY)); <span class="comment">// 2015-01-05</span></div></pre></td></tr></table></figure>
<h2 id="与-Joda-Time-的区别"><a href="#与-Joda-Time-的区别" class="headerlink" title="与 Joda-Time 的区别"></a>与 Joda-Time 的区别</h2><p>其实 JSR310 的规范领导者 Stephen Colebourne, 同时也是 Joda-Time 的创建者, JSR310 是在 Joda-Time 的基础上建立的, 参考了绝大部分的 API, 但并不是说 JSR310=JODA-Time, 下面几个比较明显的区别是</p>
<ol>
<li>最明显的变化就是包名(从 org.joda.time 以及 java.time)</li>
<li>JSR310 不接受 NULL 值, Joda-Time 视 NULL 值为 0</li>
<li>JSR310 的计算机相关的时间 (Instant) 和与人类相关的时间 (DateTime) 之间的差别变得更明显</li>
<li>JSR310 所有抛出的异常都是 DateTimeException 的子类。虽然 DateTimeException 是一个 RuntimeException</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对比旧的日期 API</p>
<table>
<thead>
<tr>
<th>Java.time</th>
<th>java.util.Calendar 以及 Date</th>
</tr>
</thead>
<tbody>
<tr>
<td>流畅的 API</td>
<td>不流畅的 API</td>
</tr>
<tr>
<td>实例不可变</td>
<td>实例可变</td>
</tr>
<tr>
<td>线程安全</td>
<td>非线程安全</td>
</tr>
</tbody>
</table>
<p>日期与时间处理 API, 在各种语言中, 可能都只是个不起眼的 API, 如果你没有较复杂的时间处理需求, 可能只是利用日期与时间处理 API 取得系统时间, 简单做些显示罢了, 然而如果认真看待日期与时间, 其复杂程度可能会远超过你的想象, 天文、地理、历史、政治、文化等因素, 都会影响到你对时间的处理。所以在处理时间上, 最好选用 JSR310(如果你用 java8 的话就实现 310 了), 或者 Joda-Time。</p>
<p>不止是 java 面临时间处理的尴尬, 其他语言同样也遇到过类似的问题, 比如</p>
<p>Arrow: Python 中更好的日期与时间处理库</p>
<p>Moment.js: JavaScript 中的日期库</p>
<p>Noda-Time: .NET 阵营的 Joda-Time 的复制</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自: &lt;a href=&quot;https://my.oschina.net/benhaile/blog/193956&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://my.oschina.net/benhaile/blog/193956&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;摘要: JSR310 已在 java8 中实现了, 对于恶心的 java.util.Date 和 Calendar, 终于可以休息了吧。。。&lt;/p&gt;
&lt;p&gt;这次给大家讲下 java8 时间与日期 API。&lt;/p&gt;
&lt;p&gt;众所周知, 日期是商业逻辑计算一个关键的部分, 任何企业应用程序都需要处理时间问题。应用程序需要知道当前的时间点和下一个时间点, 有时它们还必须计算这两个时间点之间的路径。但 java 之前的日期做法太令人恶心了, 我们先来吐槽一下&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.lyogvce.me/categories/Java/"/>
    
      <category term="日期和时间" scheme="http://blog.lyogvce.me/categories/Java/%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/"/>
    
    
      <category term="Java" scheme="http://blog.lyogvce.me/tags/Java/"/>
    
      <category term="日期和时间" scheme="http://blog.lyogvce.me/tags/%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/"/>
    
      <category term="Java 8" scheme="http://blog.lyogvce.me/tags/Java-8/"/>
    
  </entry>
  
  <entry>
    <title>一些常用的修复 Windows 系统的命令行及使用教程</title>
    <link href="http://blog.lyogvce.me/2017-03/System-Repair-Command-Of-Windows.html"/>
    <id>http://blog.lyogvce.me/2017-03/System-Repair-Command-Of-Windows.html</id>
    <published>2017-03-28T16:00:00.000Z</published>
    <updated>2017-07-16T02:26:59.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1 基础"></a>1 基础</h2><p>对于一些问题, 我们可以先试一试 <code>sfc</code> 命令.</p>
<p>简介: SFC 命令用于检查系统文件, 并可以在重启 win7 后恢复受损的系统文件.</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>/scannow</td>
<td>立即扫描所有受保护的系统文件.</td>
</tr>
<tr>
<td>/scanonce</td>
<td>一次扫描所有受保护的系统文件.</td>
</tr>
<tr>
<td>/scanboot</td>
<td>每次重启时扫描所有受保护的系统文件.</td>
</tr>
<tr>
<td>/revert</td>
<td>将扫描返回到默认操作.</td>
</tr>
<tr>
<td>/purgecache</td>
<td>立即清除 “Windows 文件保护” 文件缓存, 并扫描所有受保护的系统文件.</td>
</tr>
<tr>
<td>/cachesize=x</td>
<td>设置 “Windows 文件保护” 文件缓存的大小, 以 MB 为单位.</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>例如: 在 “命令提示符” 窗口中, 输入命令</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SFC /Scannow</div></pre></td></tr></table></figure>
<p>此命令在完成扫描及重启操作后, 一些基本的文件损坏故障就可以恢复.</p>
<h2 id="2-进阶篇"><a href="#2-进阶篇" class="headerlink" title="2 进阶篇"></a>2 进阶篇</h2><p>如果上面的方法还无法修复问题, 那么就可以试一试 dism 命令了. DISM 命令功能强大复杂, 这里就不细说.</p>
<p>操作: 管理员运行 CMD 后, 输入</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Dism/Online /Cleanup-Image /A</div></pre></td></tr></table></figure>
<p>其中, A 部分有三种格式</p>
<ol>
<li>Scanhealth 扫描所有系统文件的完整性.</li>
<li>Checkhealth 检查系统文件, 并与服务器标准对比, 然后报告偏差文件</li>
<li>Restorehealth 将所有有偏差的文件恢复至于服务器样本一致</li>
</ol>
<p>注意: 运行上面的命令时, 需要电脑有可用网络. 并且, 这条命令比较花时间, 比较消耗电脑资源, 所以修复期间建议可以干点别的.</p>
<p>补充: 对于没有网的小伙伴, 有没有不要网络的方法呢？答案当然是有的. 前提是你要有一个当前系统的 ISO 安装镜像 (其实只需要用到里面的 install.wim 文件).</p>
<p>步骤:</p>
<ol>
<li>如果是 ISO 镜像, 先挂载当前系统镜像. 如果是 install.wim 请略过这一步</li>
<li>使用 wimtool 工具挂载 install.wim 文件到指定的目录, 这里以 d:\mount 为例. 小伙伴们自己修复时只需要把 D:\mount 改为自己的路径就可以了.</li>
<li>挂载完成后管理员身份运行下面的命令 Dism /Online/Cleanup-Image /RestoreHealth /Source:D:\mount\windows /LimitAccess</li>
<li>不喜欢命令的童鞋推荐使用初雨论坛的 DISM++ 工具.</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.landiannews.com/archives/15698.html" target="_blank" rel="external">https://www.landiannews.com/archives/15698.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-基础&quot;&gt;&lt;a href=&quot;#1-基础&quot; class=&quot;headerlink&quot; title=&quot;1 基础&quot;&gt;&lt;/a&gt;1 基础&lt;/h2&gt;&lt;p&gt;对于一些问题, 我们可以先试一试 &lt;code&gt;sfc&lt;/code&gt; 命令.&lt;/p&gt;
&lt;p&gt;简介: SFC 命令用于检查系统文件, 并可以在重启 win7 后恢复受损的系统文件.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/scannow&lt;/td&gt;
&lt;td&gt;立即扫描所有受保护的系统文件.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/scanonce&lt;/td&gt;
&lt;td&gt;一次扫描所有受保护的系统文件.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/scanboot&lt;/td&gt;
&lt;td&gt;每次重启时扫描所有受保护的系统文件.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/revert&lt;/td&gt;
&lt;td&gt;将扫描返回到默认操作.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/purgecache&lt;/td&gt;
&lt;td&gt;立即清除 “Windows 文件保护” 文件缓存, 并扫描所有受保护的系统文件.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/cachesize=x&lt;/td&gt;
&lt;td&gt;设置 “Windows 文件保护” 文件缓存的大小, 以 MB 为单位.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="Windows" scheme="http://blog.lyogvce.me/categories/Windows/"/>
    
      <category term="cmd" scheme="http://blog.lyogvce.me/categories/Windows/cmd/"/>
    
    
      <category term="Windows" scheme="http://blog.lyogvce.me/tags/Windows/"/>
    
      <category term="cmd" scheme="http://blog.lyogvce.me/tags/cmd/"/>
    
  </entry>
  
  <entry>
    <title>UEFI &amp; GPT</title>
    <link href="http://blog.lyogvce.me/2017-03/UEFI-And-GPT.html"/>
    <id>http://blog.lyogvce.me/2017-03/UEFI-And-GPT.html</id>
    <published>2017-03-21T16:00:00.000Z</published>
    <updated>2017-07-16T02:27:00.546Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-引导基础篇-什么是-UEFI-什么是-GPT"><a href="#1-引导基础篇-什么是-UEFI-什么是-GPT" class="headerlink" title="1 引导基础篇: 什么是 UEFI, 什么是 GPT"></a>1 引导基础篇: 什么是 UEFI, 什么是 GPT</h2><p>本文目的是想用最简单直白的语言把内容写出来, 让每个人都能轻松读懂。当然, 如果你已经对这些内容有了很深的理解的话, 这篇文章除了浪费你的时间外恐怕是别无益处了, 建议去 UEFI 官方网站下载 UEFI 规范文档, 那里详细阐述了 UEFI、GPT 的每个技术细节。</p>
<a id="more"></a>
<p>其实 UEFI、GPT 都不是什么新鲜玩意了, 只不过因为预装 Win8 电脑指定采用了这一标准所以仿佛是在一夜之间关于 UEFI 启动 Windows 的文章就遍地开花了, 很多人大概也是头一次听说世上还有这玩意。既然 UEFI、GPT 是 “新” 技术, 那么就必然有较旧技术 (BIOS+MBR) 更先进、更 NB 的地方。到底 NB 在哪里呢？下面来简单比较一下:</p>
<h3 id="GPT-及其优势"><a href="#GPT-及其优势" class="headerlink" title="GPT 及其优势"></a>GPT 及其优势</h3><p>GPT 和 MBR 是两种不同的分区方案。目前在 Windows 下广泛采用的磁盘分区方案仍然是 MBR 分区结构, 但不容怀疑 GPT 是今后的趋势。我们可将 MBR 磁盘分区结构用下图简单表示(Windows 下基本磁盘、4 个主分区):</p>
<p><img src="../images/UEFI-And-GPT/MBR.jpg" alt="MBR 分区结构">MBR 分区结构</p>
<p>为了方便计算机访问硬盘, 把硬盘上的空间划分成许许多多的区块(英文叫 sectors, 即扇区), 然后给每个区块分配一个地址, 称为逻辑块地址(即 LBA)。</p>
<p>在 MBR 磁盘的第一个扇区内保存着启动代码和硬盘分区表。启动代码的作用是指引计算机从活动分区引导启动操作系统 (BIOS 下启动操作系统的方式); 分区表的作用是记录硬盘的分区信息。在 MBR 中, 分区表的大小是固定的, 一共可容纳 4 个主分区信息。在 MBR 分区表中逻辑块地址采用 32 位二进制数表示, 因此一共可表示 2^32(2 的 32 次方) 个逻辑块地址。如果一个扇区大小为 512 字节, 那么硬盘最大分区容量仅为 2TB。</p>
<p>GPT 磁盘分区结构可用下图简单表示(Windows 下基本磁盘):</p>
<p><img src="../images/UEFI-And-GPT/gpt.jpg" alt="GPT 分区结构">GPT 分区结构</p>
<p>可以看到, 在 GTP 磁盘的第一个数据块中同样有一个与 MBR(主引导记录)类似的标记, 叫做 PMBR。PMBR 的作用是, 当使用不支持 GPT 的分区工具时, 整个硬盘将显示为一个受保护的分区, 以防止分区表及硬盘数据遭到破坏。UEFI 并不从 PMBR 中获取 GPT 磁盘的分区信息, 它有自己的分区表, 即 GPT 分区表。</p>
<p>GPT 的分区方案之所以比 MBR 更先进, 是因为在 GPT 分区表头中可自定义分区数量的最大值, 也就是说 GPT 分区表的大小不是固定的。在 Windows 中, 微软设定 GPT 磁盘最大分区数量为 128 个。另外, GPT 分区方案中逻辑块地址 (LBA) 采用 64 位二进制数表示, 可以计算一下 2^64 是一个多么庞大的数据, 以我们的需求来讲完全有理由认为这个大小约等于无限。除此之外, GPT 分区方案在硬盘的末端还有一个备份分区表, 保证了分区信息不容易丢失。</p>
<h3 id="Windows-操作系统对-GPT-磁盘的支持"><a href="#Windows-操作系统对-GPT-磁盘的支持" class="headerlink" title="Windows 操作系统对 GPT 磁盘的支持"></a>Windows 操作系统对 GPT 磁盘的支持</h3><p>因为 BIOS 无法识别 GPT 分区, 所以 BIOS 下 GPT 磁盘不能用于启动操作系统, 在操作系统提供支持的情况下可用于数据存储。</p>
<p>UEFI 可同时识别 MBR 分区和 GPT 分区, 因此 UEFI 下, MBR 磁盘和 GPT 磁盘都可用于启动操作系统和数据存储。不过微软限制, UEFI 下使用 Windows 安装程序安装操作系统是只能将系统安装在 GPT 磁盘中。</p>
<p>下表列出了 Windows 各版本操作系统对 GPT 磁盘的支持程度:</p>
<p><img src="../images/UEFI-And-GPT/1.jpg" alt="32 位 Windows 对 GPT 分区支持情况">32 位 Windows 对 GPT 分区支持情况</p>
<p><img src="../images/UEFI-And-GPT/2.jpg" alt="64 位 Windows 对 GPT 分区支持情况">64 位 Windows 对 GPT 分区支持情况</p>
<h3 id="UEFI-及其优势"><a href="#UEFI-及其优势" class="headerlink" title="UEFI 及其优势"></a>UEFI 及其优势</h3><p>UEFI 是 BIOS 的一种升级替代方案。关于 BIOS 和 UEFI 二者的比较, 网络上已经有很多相关的文章, 这里不再赘述, 仅从系统启动原理方面来做比较。UEFI 之所以比 BIOS 强大, 是因为 UEFI 本身已经相当于一个微型操作系统, 其带来的便利之处在于:</p>
<p><strong> 首先, </strong>UEFI 已具备文件系统的支持, 它能够直接读取 FAT 分区中的文件;</p>
<blockquote>
<p>什么是文件系统？简单说, 文件系统是操作系统组织管理文件的一种方法, 直白点说就是把硬盘上的数据以文件的形式呈现给用户。Fat32、NTFS 都是常见的文件系统类型。</p>
</blockquote>
<p><strong>其次,</strong> 可开发出直接在 UEFI 下运行的应用程序, 这类程序文件通常以 efi 结尾。</p>
<p>既然 UEFI 可以直接识别 FAT 分区中的文件, 又有可直接在其中运行的应用程序。那么完全可以 <strong>将 Windows 安装程序做成 efi 类型应用程序, 然后把它放到任意 fat 分区中直接运行即可</strong>, 如此一来安装 Windows 操作系统这件过去看上去稍微有点复杂的事情突然就变非常简单了, 就像在 Windows 下打开 QQ 一样简单。而事实上, 也就是这么一回事。</p>
<p>要知道, 这些都是 BIOS 做不到的。因为 BIOS 下启动操作系统之前, 必须从硬盘上指定扇区读取系统启动代码 (包含在主引导记录中), 然后从活动分区中引导启动操作系统。对扇区的操作远比不上对分区中文件的操作更直观更简单, 所以在 BIOS 下引导安装 Windows 操作系统, 我们不得不使用一些工具对设备进行配置以达到启动要求。而在 UEFI 下, 这些统统都不需要, <strong>不再需要主引导记录, 不再需要活动分区, 不需要任何工具, 只要复制安装文件到一个 FAT32(主) 分区 / U 盘中, 然后从这个分区 / U 盘启动, 安装 Windows 就是这么简单</strong>。后面会有专门的文章来详细介绍 UEFI 下安装 Windows7、8 的方法。</p>
<h2 id="2-引导实践篇-一-切换到-UEFI-启动-准备安装介质"><a href="#2-引导实践篇-一-切换到-UEFI-启动-准备安装介质" class="headerlink" title="2 引导实践篇(一): 切换到 UEFI 启动, 准备安装介质"></a>2 引导实践篇(一): 切换到 UEFI 启动, 准备安装介质</h2><p>如果只单纯比较 UEFI 引导和 BIOS 引导, 那么毫无疑问 UEFI 引导要简单很多。不过现在的主板大都是同时兼容 BIOS 和 UEFI 引导方式, 所以在实际操作前还需要确认一些东西。详见下文。</p>
<h3 id="1、我的电脑支不支持-UEFI-启动？"><a href="#1、我的电脑支不支持-UEFI-启动？" class="headerlink" title="1、我的电脑支不支持 UEFI 启动？"></a>1、我的电脑支不支持 UEFI 启动？</h3><p>要通过 UEFI 方式启动 Windows7/8, 电脑需要支持 UEFI 启动。预装 Win8 的电脑都支持 UEFI 启动。近两年的主板很多也都支持 UEFI 启动。开机出现品牌标识按 F2(或者 DEL、ESC 等按键, 不通品牌按键不通)进入 BIOS/UEFI 设置, 在 Boot 项或类似项中查看有无 EFI/UEFI 相关选项, 如果有, 那么说明电脑支持 UEFI 启动。下图是联想 Y480UEFI 选项:</p>
<p><img src="../images/UEFI-And-GPT/3.jpg" alt="联想 Y480 UEFI 引导选项">联想 Y480 UEFI 引导选项</p>
<h3 id="2、想要-UEFI-启动-我该选择安装什么操作系统？"><a href="#2、想要-UEFI-启动-我该选择安装什么操作系统？" class="headerlink" title="2、想要 UEFI 启动, 我该选择安装什么操作系统？"></a>2、想要 UEFI 启动, 我该选择安装什么操作系统？</h3><p>目前几乎所有支持 UEFI 的个人电脑都是 64 位 UEFI 系统, 仅支持 64 位 Vista、64 位 Win7 以及 64 位 Win8/8.1。所以你只能从这几个操作系统中选择。切记, 只有原版镜像支持光盘 UEFI 启动, 一定要选择下载微软原版系统！<strong>建议选择的版本:</strong> 不管是 Win7、Win8 或 Win8.1, 都建议选择专业版; 激活都选择<a href="http://www.iruanmi.com/kmspico/" target="_blank" rel="external">KMS 激活方式</a>。</p>
<p><strong>提示:</strong> 已经下载了 Win7 旗舰版镜像的朋友, 如采用 U 盘安装或从硬盘引导安装(后面会讲到), 在准备好安装介质后只需要删除 sources 文件夹下面的 ei.cfg 文件即可选择安装除企业版之外任意版本, 包括专业版。</p>
<h3 id="3、预装-Win8-的电脑想要安装-64-位-Win7、Vista-需关闭安全启动-并开启-CSM"><a href="#3、预装-Win8-的电脑想要安装-64-位-Win7、Vista-需关闭安全启动-并开启-CSM" class="headerlink" title="3、预装 Win8 的电脑想要安装 64 位 Win7、Vista 需关闭安全启动, 并开启 CSM"></a>3、预装 Win8 的电脑想要安装 64 位 Win7、Vista 需关闭安全启动, 并开启 CSM</h3><p>具体选项:<br>① 某些预装 Win8 的电脑有名为 OS Optimized Defaults 的设置选项, 需要将这个选项设置为 Disabled。<br>② 找到类似 “Boot mode” 或者 “UEFI/Legacy Boot” 设置项, 将其设置为 “UEFI” 或类似选项。<br>③ 如果能找到 “Lunch CSM” 或类似选项, 将其设为 “Enabled”, 即开启状态。<br>④ 找到 “Secure Boot” 或类似选项, 将其设为 “Disabled”, 即关闭状态。不关闭安全启动, 无法安装 Win8 之外的操作系统。<br>详细教程: 《<a href="http://www.iruanmi.com/install-64bit-windows-7-on-a-pre-installed-win8-pc/" target="_blank" rel="external">预装 64 位 Win8/8.1 电脑安装 64 位 Win7 详细过程(单 / 双系统)</a>》</p>
<h3 id="4、-非安装双系统跳过此步-为将要安装的操作系统开辟新的分区"><a href="#4、-非安装双系统跳过此步-为将要安装的操作系统开辟新的分区" class="headerlink" title="4、(非安装双系统跳过此步)为将要安装的操作系统开辟新的分区"></a>4、(非安装双系统跳过此步)为将要安装的操作系统开辟新的分区</h3><p>如果想要在现有系统基础上再安装一个操作系统组成双系统, 首先你现有的系统必须为 UEFI+GPT 引导(例如, 预装 Win8 系统), 否则只能在安装过程中删除硬盘所有数据自动完成转换。<br>确定是否为 GPT 分区: 打开磁盘管理, 找到硬盘 0, 然后右键点击。如果有灰色选项 “转换成 MBR 磁盘” 则说明硬盘为 GPT 分区, 如下图①所示, 并且系统一定为 UEFI 引导。<br>开辟新分区的方法: 打开磁盘管理, 在剩余空间较大的分区上右键点击, 选择 “压缩”, 如下图 2 所示。然后输入合适的大小压缩即可(推荐不小于 50G)。</p>
<p><img src="../images/UEFI-And-GPT/4.png" alt="查看硬盘分区结构 &amp; 压缩分区空间">查看硬盘分区结构 &amp; 压缩分区空间</p>
<h3 id="5、准备安装介质"><a href="#5、准备安装介质" class="headerlink" title="5、准备安装介质"></a>5、准备安装介质</h3><p>有三种选择:</p>
<p>一、可以将微软原版 64 为 Win7 镜像、64 位 Win8 镜像直接刻入光盘, 从光盘启动安装。<br>二、可以准备一个容量不小于 4G 的 U 盘, 格式化为 FAT32, 然后复制 64 为 Win7 镜像或 64 位 Win8 镜像中的所有文件到 U 盘根目录, 文件结构如下图①所示。如果安装的是 64 位 Win7, 还需要下载 bootx64.efi 文件(<a href="http://pan.baidu.com/s/1qWDH6Ny" target="_blank" rel="external">点击下载</a>), 然后在 U 盘中 efi 文件夹下新建名为 boot 的文件夹, 把 bootx64.efi 文件放到里边。如下图②所示。<br><img src="../images/UEFI-And-GPT/5.png" alt="启动介质中文件结构"></p>
<p>启动介质中文件结构</p>
<p>三、也可以在电脑硬盘或者移动硬盘 (都必须为 GPT 分区) 任意位置压缩出一个分区(大小在 4G~30G 之间), 格式化为 FAT32, 然后参考上一条复制文件即可。</p>
<p><strong>特别提示:</strong> 如果下载的是 Win7 旗舰版, 想要安装专业版, 只需在准备好安装介质后删掉 sources 目录中的 ei.cfg 文件即可选择安装除企业版之外的任意版本, 包括专业版。</p>
<p>OK, 要准备的就这些。安装过程请参考《<a href="http://www.iruanmi.com/install-win7-or-win8-on-uefi-platform/" target="_blank" rel="external">UEFI+GPT 引导实践篇(二): UEFI 引导安装 64 位 Win7/Win8</a>》。</p>
<h2 id="3-UEFI-GPT-引导实践篇-二-UEFI-引导安装-64-位-Win7-Win8"><a href="#3-UEFI-GPT-引导实践篇-二-UEFI-引导安装-64-位-Win7-Win8" class="headerlink" title="3 UEFI+GPT 引导实践篇(二): UEFI 引导安装 64 位 Win7/Win8"></a>3 UEFI+GPT 引导实践篇(二): UEFI 引导安装 64 位 Win7/Win8</h2><p>下文是在联想 Y480 笔记本上以 UEFI 方式启动安装 Windows8 的全过程, 安装 Windows7 过程基本相同。注意, 如果你的电脑硬盘是 MBR 分区结构, 安装过程中将要删除硬盘上所有数据, 请安装前备份硬盘上的所有个人文件。</p>
<p><strong> 准备容量不小于 4G 的 U 盘一个, 格式化为 FAT32。然后复制 64 位 Win8 镜像中的所有文件到 U 盘根目录。</strong> 注: 如果安装的是 64 位 Win7, 还需要下载 bootx64.efi 文件(<a href="http://pan.baidu.com/s/1qWDH6Ny" target="_blank" rel="external">点击下载</a>), 然后在 U 盘中 efi 文件夹下新建名为 boot 的文件夹, 把 bootx64.efi 文件放到里边。预装 Win8/8.1 电脑安装 Win7 还需要更改几个 BIOS 设置, 相关准备工作请参考《<a href="http://www.iruanmi.com/get-ready-for-installing/" target="_blank" rel="external">UEFI+GPT 引导准备篇: 切换到 UEFI 启动, 准备安装介质</a>》或参考专门针对此情况的完整教程《<a href="http://www.iruanmi.com/install-64bit-windows-7-on-a-pre-installed-win8-pc/" target="_blank" rel="external">预装 64 位 Win8/8.1 电脑安装 64 位 Win7 详细过程(单 / 双系统)</a>》。</p>
<p>重启电脑, 出现联想标识时按 F2 打开 BIOS 设置界面, 切换到 “boot” 设置界面将 UEFI Boot 设置项设置为 “Enable”, 这样就开启了 UEFI。按 F10 键, 保存设置。</p>
<p><img src="../images/UEFI-And-GPT/6.jpg" alt="1"></p>
<p>重启, 在出现联想标识时按 F12 键, 此时出现启动设备选择界面, 我们可以看到这里有两个 USB 设备。图中被选中的名称前面可以看到 “EFI” 字样, 这就表示该设备是可以 EFI 引导的设备。我们就需要选择这一项。</p>
<p><img src="../images/UEFI-And-GPT/7.jpg" alt="2"></p>
<p>选中图中的选项后, 电脑会开始加载 Windows 预安装环境文件。(注: 小编实际操作时安装的是 64 位 Win7, 但是手机拍下来的图很不清晰, 所以就在虚拟机中在 UEFI 模式下安装了 64 位 Win8, 二者无区别)</p>
<p><img src="../images/UEFI-And-GPT/8.png" alt="Windows 8-2013-06-08-20-09-47"></p>
<p>稍等出现下面的界面, 默认即可。</p>
<p><img src="../images/UEFI-And-GPT/9.png" alt="Windows 8-2013-06-08-20-10-56"></p>
<p>上图: 点下一步</p>
<p><img src="../images/UEFI-And-GPT/10.png" alt="Windows 8-2013-06-08-20-11-05"></p>
<p>上图: 点 “现在安装”</p>
<p><img src="../images/UEFI-And-GPT/11.png" alt="Windows 8-2013-06-08-20-11-15"></p>
<p><img src="../images/UEFI-And-GPT/12.png" alt="Windows 8-2013-06-08-20-12-20"></p>
<p><img src="../images/UEFI-And-GPT/13.png" alt="Windows 8-2013-06-08-20-12-38"></p>
<p><img src="../images/UEFI-And-GPT/14.png" alt="Windows 8-2013-06-08-20-12-45"></p>
<p>上图: 这里选择 “自定义”, 进入分区选择界面。如果你的电脑硬盘已经为 GPT 分区结构, 那么直接选择目标分区, 将其格式化, 然后选中点下一步即可。下面是硬盘位 MBR 分区结构的情况:</p>
<p><img src="../images/UEFI-And-GPT/15.png" alt="Windows 8-2013-06-08-20-13-39"></p>
<p>上图: 如果你的电脑硬盘为 MBR 分区结构, 那么会看到 “无法在驱动器 X 的分区 x 上安装 Windows” 的提示, 这时候需要点击 “驱动器选项(高级)”, 然后删除硬盘上所有的分区使得整个硬盘变成一块未分配空间。提示: 在这一步你也可以按 Shift+F10 或者 Shift+Fn+F10 调出命令提示符窗口, 然后借助 diskpart 工具将硬盘转换为 GPT 分区。命令详见《<a href="http://www.iruanmi.com/convert-gpt-to-mbr-or-convert-mbr-to-gpt-use-diskpart-tool/" target="_blank" rel="external">Diskpart 工具应用两则: MBR/GPT 分区转换 &amp; 基本 / 动态磁盘转换</a>》。</p>
<p><img src="../images/UEFI-And-GPT/16.png" alt="Windows 8-2013-06-08-20-19-11"></p>
<p>上图: 整个硬盘已成为一块未分配空间。点击 “新建”, 输入想要为系统安装分区分配的空间大小(推荐不小于 50G), 点击 “应用”。</p>
<p><img src="../images/UEFI-And-GPT/17.png" alt="Windows 8-2013-06-08-20-19-27"></p>
<p>上图: 此时提示将创建额外的分区, 点击 “确定”。之后安装程序会自动将硬盘转换为 GPT 分区。创建完成后你将看到四个创建好的分区, 如下图所示。关于这些分区的作用详见《<a href="http://www.iruanmi.com/win8-oem-devices-disk-partition-analysis/" target="_blank" rel="external">用于引导 Windows 的 GPT 磁盘 (预装 Win8 电脑) 各分区作用详解</a>》</p>
<p><img src="../images/UEFI-And-GPT/18.png" alt="Windows 8-2013-06-08-20-20-06"></p>
<p>选择第一个主分区, 然后点 “下一步” 就开始安装了。之后根据提示操作即可完成系统安装。</p>
<p><img src="../images/UEFI-And-GPT/19.png" alt="Windows 8-2013-06-08-20-20-13"></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>实际上只有遵循 UEFI 规范的主板才能按照 efi/boot/bootx64.efi 路径启动 Windows 安装程序, 大多数主板都是遵循这一规范的。如果不遵循这一规范, 那么你需要手动选择从该文件启动, 或者需要在 UEFI Shell 中以命令的方式启动 bootx64.efi。关于这些后面会有文章来详解。另外关于预装 Win8 电脑改装 Win7 或者安装 Win8+Win7 双系统都会有专门教程。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>整理自:<br><a href="http://www.iruanmi.com/what-is-gpt-and-what-is-uefi/" target="_blank" rel="external">http://www.iruanmi.com/what-is-gpt-and-what-is-uefi/</a><br><a href="http://www.iruanmi.com/get-ready-for-installing/" target="_blank" rel="external">http://www.iruanmi.com/get-ready-for-installing/</a><br><a href="http://www.iruanmi.com/install-win7-or-win8-on-uefi-platform/" target="_blank" rel="external">http://www.iruanmi.com/install-win7-or-win8-on-uefi-platform/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-引导基础篇-什么是-UEFI-什么是-GPT&quot;&gt;&lt;a href=&quot;#1-引导基础篇-什么是-UEFI-什么是-GPT&quot; class=&quot;headerlink&quot; title=&quot;1 引导基础篇: 什么是 UEFI, 什么是 GPT&quot;&gt;&lt;/a&gt;1 引导基础篇: 什么是 UEFI, 什么是 GPT&lt;/h2&gt;&lt;p&gt;本文目的是想用最简单直白的语言把内容写出来, 让每个人都能轻松读懂。当然, 如果你已经对这些内容有了很深的理解的话, 这篇文章除了浪费你的时间外恐怕是别无益处了, 建议去 UEFI 官方网站下载 UEFI 规范文档, 那里详细阐述了 UEFI、GPT 的每个技术细节。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机相关" scheme="http://blog.lyogvce.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="装机" scheme="http://blog.lyogvce.me/tags/%E8%A3%85%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>如何为 RHEL / CentOS 7.x / 6.x / 5.x 启用 EPEL 存储库</title>
    <link href="http://blog.lyogvce.me/2017-01/Enable-Epel-Repo-For-RHEL-And-CentOS.html"/>
    <id>http://blog.lyogvce.me/2017-01/Enable-Epel-Repo-For-RHEL-And-CentOS.html</id>
    <published>2017-01-21T16:00:00.000Z</published>
    <updated>2017-07-16T02:26:59.915Z</updated>
    
    <content type="html"><![CDATA[<p><strong>待整理</strong></p>
<p><strong>2016 年 8 月 17 日</strong><a href="http://www.howtoing.com/category/operating-system/centos/" target="_blank" rel="external">CentOS 系统</a> <a href="http://www.howtoing.com/category/operating-system/redhat/" target="_blank" rel="external">RedHat</a></p>
<p>这个指南手册显示了您将如何启用 RHEL / CentOS 的 6/5 <strong>EPEL 软件库</strong>, 以便使用 yum 命令来安装额外的标准开源软件包.</p>
<a id="more"></a>
<p><strong>另请参阅</strong> :  <a href="http://www.howtoing.com/enable-rpmforge-repository/" target="_blank" rel="external">安装和 RHEL 启用 RPMForge 软件库 / CentOS 7/6/5/4</a></p>
<h2 id="什么是-EPEL"><a href="#什么是-EPEL" class="headerlink" title="什么是 EPEL"></a>什么是 EPEL</h2><p><strong>EPEL</strong>(额外的企业版 Linux 软件包) 是开源和基于免费的社区信息库项目由 Fedora 的团队, 提供 100％的高品质的附加软件包的 Linux 发行版, 包括 RHEL(红帽企业 Linux), CentOS 的, 与科学 Linux 操作系统. Epel 项目不是 RHEL / Cent OS 的一部分, 但它是为主要的 Linux 发行版本提供的, 它提供了许多开源软件包, 如网络, 系统管理, 编程, 监视等等. 大多数 epel 软件包由 Fedora 软件库维护.</p>
<h2 id="为什么我们使用-EPEL-存储库"><a href="#为什么我们使用-EPEL-存储库" class="headerlink" title="为什么我们使用 EPEL 存储库"></a>为什么我们使用 EPEL 存储库</h2><ol>
<li>提供许多开源包以通过 Yum 安装.</li>
<li>EPEL 仓库是 100％开源和免费使用.</li>
<li>它不提供任何核心重复的软件包和没有兼容性问题.</li>
<li>所有 epel 包都由 Fedora 库维护.</li>
</ol>
<h2 id="如何在-RHEL-CentOS-7-6-5-中启用-EPEL-存储库"><a href="#如何在-RHEL-CentOS-7-6-5-中启用-EPEL-存储库" class="headerlink" title="如何在 RHEL / CentOS 7/6/5 中启用 EPEL 存储库"></a>如何在 RHEL / CentOS 7/6/5 中启用 EPEL 存储库</h2><p>首先, 您需要使用 <code>wget</code> 下载的文件, 然后使用你的系统上 <code>RPM</code> 启用 EPEL 软件库安装它. 根据您的 Linux 操作系统版本使用以下链接. <strong>请确保您必须是 root 用户</strong> ).</p>
<h3 id="RHEL-CentOS-7-64-位"><a href="#RHEL-CentOS-7-64-位" class="headerlink" title="RHEL / CentOS 7 64 位"></a>RHEL / CentOS 7 64 位</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">## RHEL/CentOS 7 64-Bit ##</span></div><div class="line"><span class="comment"># wget http://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-8.noarch.rpm</span></div><div class="line"><span class="comment"># rpm -ivh epel-release-7-8.noarch.rpm</span></div></pre></td></tr></table></figure>
<h3 id="RHEL-CentOS-6-32-64-位"><a href="#RHEL-CentOS-6-32-64-位" class="headerlink" title="RHEL / CentOS 6 32-64 位"></a>RHEL / CentOS 6 32-64 位</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">## RHEL/CentOS 6 32-Bit ##</span></div><div class="line"><span class="comment"># wget http://download.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm</span></div><div class="line"><span class="comment"># rpm -ivh epel-release-6-8.noarch.rpm</span></div><div class="line"><span class="comment">## RHEL/CentOS 6 64-Bit ##</span></div><div class="line"><span class="comment"># wget http://download.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm</span></div><div class="line"><span class="comment"># rpm -ivh epel-release-6-8.noarch.rpm</span></div></pre></td></tr></table></figure>
<h3 id="RHEL-CentOS-5-32-64-位"><a href="#RHEL-CentOS-5-32-64-位" class="headerlink" title="RHEL / CentOS 5 32-64 位"></a>RHEL / CentOS 5 32-64 位</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">## RHEL/CentOS 5 32-Bit ##</span></div><div class="line"><span class="comment"># wget http://download.fedoraproject.org/pub/epel/5/i386/epel-release-5-4.noarch.rpm</span></div><div class="line"><span class="comment"># rpm -ivh epel-release-5-4.noarch.rpm</span></div><div class="line"><span class="comment">## RHEL/CentOS 5 64-Bit ##</span></div><div class="line"><span class="comment"># wget http://download.fedoraproject.org/pub/epel/5/x86_64/epel-release-5-4.noarch.rpm</span></div><div class="line"><span class="comment"># rpm -ivh epel-release-5-4.noarch.rpm</span></div></pre></td></tr></table></figure>
<h3 id="RHEL-CentOS-4-32-64-位"><a href="#RHEL-CentOS-4-32-64-位" class="headerlink" title="RHEL / CentOS 4 32-64 位"></a>RHEL / CentOS 4 32-64 位</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">## RHEL/CentOS 4 32-Bit ##</span></div><div class="line"><span class="comment"># wget http://download.fedoraproject.org/pub/epel/4/i386/epel-release-4-10.noarch.rpm</span></div><div class="line"><span class="comment"># rpm -ivh epel-release-4-10.noarch.rpm</span></div><div class="line"><span class="comment">## RHEL/CentOS 4 64-Bit ##</span></div><div class="line"><span class="comment"># wget http://download.fedoraproject.org/pub/epel/4/x86_64/epel-release-4-10.noarch.rpm</span></div><div class="line"><span class="comment"># rpm -ivh epel-release-4-10.noarch.rpm</span></div></pre></td></tr></table></figure>
<h2 id="如何验证-EPEL-仓库"><a href="#如何验证-EPEL-仓库" class="headerlink" title="如何验证 EPEL 仓库"></a>如何验证 EPEL 仓库</h2><p>您需要运行以下命令来验证是否已启用 EPEL 存储库. 一旦你运行命令, 你将看到 epel 存储库.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># yum repolist</span></div></pre></td></tr></table></figure>
<p><strong>示例输出</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Loaded plugins: downloadonly, fastestmirror, priorities</div><div class="line">Loading mirror speeds from cached hostfile</div><div class="line">* base: centos.aol.in</div><div class="line">* epel: ftp.cuhk.edu.hk</div><div class="line">* extras: centos.aol.in</div><div class="line">* rpmforge: be.mirror.eurid.eu</div><div class="line">* updates: centos.aol.in</div><div class="line">Reducing CentOS-5 Testing to included packages only</div><div class="line">Finished</div><div class="line">1469 packages excluded due to repository priority protections</div><div class="line">repo id                           repo name                                                      status</div><div class="line">base                              CentOS-5 - Base                                               2,718+7</div><div class="line">epel Extra Packages <span class="keyword">for</span> Enterprise Linux 5 - i386 4,320+1,408</div><div class="line">extras                            CentOS-5 - Extras                                              229+53</div><div class="line">rpmforge                          Red Hat Enterprise 5 - RPMforge.net - dag                      11,251</div><div class="line">repolist: 19,075</div></pre></td></tr></table></figure>
<h2 id="如何使用-EPEL-仓库"><a href="#如何使用-EPEL-仓库" class="headerlink" title="如何使用 EPEL 仓库"></a>如何使用 EPEL 仓库</h2><p>您需要使用 <code>yum</code> 命令用于搜索和安装软件包. 例如, 我们使用 EPEL 仓库搜索的 zabbix 软件包, 让我们看看它是否可用下 EPEL.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># yum --enablerepo=epel info zabbix</span></div></pre></td></tr></table></figure>
<p><strong>示例输出</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Available Packages</div><div class="line">Name       : zabbix</div><div class="line">Arch       : i386</div><div class="line">Version    : 1.4.7</div><div class="line">Release    : 1.el5</div><div class="line">Size       : 1.7 M</div><div class="line">Repo : epel</div><div class="line">Summary    : Open-source monitoring solution <span class="keyword">for</span> your IT infrastructure</div><div class="line">URL        : http://www.zabbix.com/</div><div class="line">License    : GPL</div><div class="line">Description: ZABBIX is software that monitors numerous parameters of a network.</div></pre></td></tr></table></figure>
<p>让我们使用 EPEL 仓库选项 <strong>-enablerepo = EPEL</strong> 开关安装的 zabbix 软件包.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># yum --enablerepo=epel install zabbix</span></div></pre></td></tr></table></figure>
<p><strong>注</strong>: EPEL 配置文件位于 <strong>/etc/yum.repos.d/epel.repo. </strong></p>
<p>这样, 您就可以安装多达使用 <strong>EPEL</strong> 回购高标准的开源软件包.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;待整理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2016 年 8 月 17 日&lt;/strong&gt;&lt;a href=&quot;http://www.howtoing.com/category/operating-system/centos/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CentOS 系统&lt;/a&gt; &lt;a href=&quot;http://www.howtoing.com/category/operating-system/redhat/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RedHat&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个指南手册显示了您将如何启用 RHEL / CentOS 的 6/5 &lt;strong&gt;EPEL 软件库&lt;/strong&gt;, 以便使用 yum 命令来安装额外的标准开源软件包.&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.lyogvce.me/categories/Linux/"/>
    
      <category term="运维" scheme="http://blog.lyogvce.me/categories/Linux/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="运维" scheme="http://blog.lyogvce.me/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="CentOS" scheme="http://blog.lyogvce.me/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>用 shell 实现 tree 命令</title>
    <link href="http://blog.lyogvce.me/2017-01/Implement-Tree-Command-Use-Shell.html"/>
    <id>http://blog.lyogvce.me/2017-01/Implement-Tree-Command-Use-Shell.html</id>
    <published>2017-01-10T16:00:00.000Z</published>
    <updated>2017-07-16T02:26:59.950Z</updated>
    
    <content type="html"><![CDATA[<p><strong>待整理</strong></p>
<p><a href="http://yijiebuyi.com/blog/c0defa3a47d16e675d58195adc35514b.html" target="_blank" rel="external">http://yijiebuyi.com/blog/c0defa3a47d16e675d58195adc35514b.html</a></p>
<a id="more"></a>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;待整理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://yijiebuyi.com/blog/c0defa3a47d16e675d58195adc35514b.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://yijiebuyi.com/blog/c0defa3a47d16e675d58195adc35514b.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.lyogvce.me/categories/Linux/"/>
    
      <category term="Shell" scheme="http://blog.lyogvce.me/categories/Linux/Shell/"/>
    
    
      <category term="Shell" scheme="http://blog.lyogvce.me/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Win10/Ubuntu 双系统</title>
    <link href="http://blog.lyogvce.me/2016-12/Dual-Ssystem-Of-Windows-And-Ubuntu.html"/>
    <id>http://blog.lyogvce.me/2016-12/Dual-Ssystem-Of-Windows-And-Ubuntu.html</id>
    <published>2016-12-15T16:00:00.000Z</published>
    <updated>2017-07-16T02:26:59.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><p>EasyBCD 软件 + 镜像文件</p>
<h2 id="Step-1-划分空间"><a href="#Step-1-划分空间" class="headerlink" title="Step 1 划分空间"></a>Step 1 划分空间</h2><p>在 Win10 磁盘管理分出大约 20 G 的空间(可以通过 <code>压缩卷</code> 获得), 划好要给 Ubuntu 的分区后, 删除卷, <code>划分出来的部分显示为黑色</code>.</p>
<h2 id="Step-2-禁用安全启动"><a href="#Step-2-禁用安全启动" class="headerlink" title="Step 2 禁用安全启动"></a>Step 2 禁用安全启动</h2><p>禁用主板 (BIOS or UEFI) 上的 Secure Boot: 设置 - 更新和安全 - 恢复 - 高级启动 - 疑难解答 - 高级选项 - UEFI 固件设置 - 重新启动</p>
<a id="more"></a>
<p>会进入类似 BIOS 的界面: Boot - Secure Boot - Disable</p>
<h2 id="Step-3-安装"><a href="#Step-3-安装" class="headerlink" title="Step 3 安装"></a>Step 3 安装</h2><p>将 Ubuntu 刻录到 U 盘上, 重启(设置 - 更新和安全 - 恢复 - 高级启动), 从 U 盘启动, 进入 Ubuntu 安装界面.</p>
<p>我们要手动分盘符, 所以, 出现下图时, 选择 “其它选项”</p>
<p><img src="../images/Dual-Ssystem-Of-Windows-And-Ubuntu/1.png" alt="1"></p>
<p>选中其中标有 “空闲” 的盘符, 这个盘符就是我们用于安装 Ubuntu 的 20 G 空间, 别动别的盘符, 点击下方的 “+”</p>
<p><img src="../images/Dual-Ssystem-Of-Windows-And-Ubuntu/2.jpg" alt="2"></p>
<p>接下来, 我们要进行四次分区, 每次都是从 “空闲” 中分出部分区域</p>
<ul>
<li>第一次分区</li>
</ul>
<p>选中 “空闲”, 点 “+”, 如下设置</p>
<p>大小: 200 MB</p>
<p>新分区的类型: 逻辑分区</p>
<p>新分区的位置: 空间起始位置</p>
<p>用于: EXT4 日志文件系统</p>
<p>挂载点: /boot (双系统引导时需要)</p>
<p>如下图所示</p>
<p><img src="../images/Dual-Ssystem-Of-Windows-And-Ubuntu/3.png" alt="5"></p>
<ul>
<li>第二次分区</li>
</ul>
<p>选中 “空闲”, 点 “+”, 如下设置</p>
<p>大小: 2048 MB</p>
<p>新分区的类型: 逻辑分区</p>
<p>新分区的位置: 空间起始位置</p>
<p>用于: 交换空间</p>
<p>挂载点: (不设置)</p>
<p>如下图所示</p>
<p><img src="../images/Dual-Ssystem-Of-Windows-And-Ubuntu/4.png" alt="4"></p>
<ul>
<li>第三次分区</li>
</ul>
<p>选中 “空闲”, 点 “+”, 如下设置</p>
<p>大小: 10240 MB</p>
<p>新分区的类型: 主分区</p>
<p>新分区的位置: 空间起始位置</p>
<p>用于: EXT4 日志文件系统</p>
<p>挂载点: “/“</p>
<p>如下图所示</p>
<p><img src="../images/Dual-Ssystem-Of-Windows-And-Ubuntu/5.png" alt="3"></p>
<ul>
<li>第四次分区</li>
</ul>
<p>选中 “空闲”, 点 “+”, 如下设置</p>
<p>大小: (剩余全部空间, 剩下显示多少, 就多少)</p>
<p>新分区的类型: 主分区</p>
<p>新分区的位置: 空间起始位置</p>
<p>用于: EXT4 日志文件系统</p>
<p>挂载点: /home</p>
<p>如下图所示</p>
<p><img src="../images/Dual-Ssystem-Of-Windows-And-Ubuntu/6.png" alt="6"></p>
<p>分区设置完毕后, 下方还有一项 “安装启动引导器的设备”, 默认就如如下图所示那样 <code>sda</code>, 如果选择默认, 则是用 Ubuntu 的 grub 引导 Windows 和 Ubuntu, 卸载 Ubuntu 时可能会麻烦些.</p>
<p>如果想用 Windows 的引导来引导 Windows 和 Ubuntu(<strong>推荐</strong>), 请选择 <code>/boot 所在的盘符</code>, 然后在 Windows 下安装引导类的软件(如: EasyBCD, 见 Step 4), 才能启动 Ubuntu. 优点是不管怎么搞, 不会把 Windows 搞坏. 用 Windows 引导 Ubuntu 最大的好处就是, 当不再需要 Ubuntu 的时候, 直接在 Windows 磁盘管理中将其所有分区删除, 然后将 EasyBCD 中对应条目删除即可.</p>
<p><img src="../images/Dual-Ssystem-Of-Windows-And-Ubuntu/7.jpg" alt="7"></p>
<p>PS1: 然后点击 “现在安装”, 如果出错不能继续, 说什么分区不对, 就把是主分区的新分区, 都重新设置为逻辑分区, 就可以了.</p>
<p>PS2: 设置好之后记住 <code>/boot</code> 所在的分区位置, 下面要用到.</p>
<h2 id="Step-4"><a href="#Step-4" class="headerlink" title="Step 4"></a>Step 4</h2><p>进入 Win10 之后, 安装 EasyBCD, 然后新增一个启动项, 选择 Linux/Grub2, 启动位置选择刚才 <code>/boot</code> 所在的位置(如果没有给 <code>/boot</code> 分区, 则是 <code>/</code> 所在的位置), 保存退出, 重启就可以看到 Ubuntu 的入口了.</p>
<p>如下图所示</p>
<p><img src="../images/Dual-Ssystem-Of-Windows-And-Ubuntu/8.png" alt="8"></p>
<p><img src="../images/Dual-Ssystem-Of-Windows-And-Ubuntu/9.png" alt="9"></p>
<p><img src="../images/Dual-Ssystem-Of-Windows-And-Ubuntu/10.jpg" alt="10"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前置&quot;&gt;&lt;a href=&quot;#前置&quot; class=&quot;headerlink&quot; title=&quot;前置&quot;&gt;&lt;/a&gt;前置&lt;/h2&gt;&lt;p&gt;EasyBCD 软件 + 镜像文件&lt;/p&gt;
&lt;h2 id=&quot;Step-1-划分空间&quot;&gt;&lt;a href=&quot;#Step-1-划分空间&quot; class=&quot;headerlink&quot; title=&quot;Step 1 划分空间&quot;&gt;&lt;/a&gt;Step 1 划分空间&lt;/h2&gt;&lt;p&gt;在 Win10 磁盘管理分出大约 20 G 的空间(可以通过 &lt;code&gt;压缩卷&lt;/code&gt; 获得), 划好要给 Ubuntu 的分区后, 删除卷, &lt;code&gt;划分出来的部分显示为黑色&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Step-2-禁用安全启动&quot;&gt;&lt;a href=&quot;#Step-2-禁用安全启动&quot; class=&quot;headerlink&quot; title=&quot;Step 2 禁用安全启动&quot;&gt;&lt;/a&gt;Step 2 禁用安全启动&lt;/h2&gt;&lt;p&gt;禁用主板 (BIOS or UEFI) 上的 Secure Boot: 设置 - 更新和安全 - 恢复 - 高级启动 - 疑难解答 - 高级选项 - UEFI 固件设置 - 重新启动&lt;/p&gt;
    
    </summary>
    
      <category term="生产力" scheme="http://blog.lyogvce.me/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B/"/>
    
    
      <category term="生产力" scheme="http://blog.lyogvce.me/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"/>
    
      <category term="双系统" scheme="http://blog.lyogvce.me/tags/%E5%8F%8C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="装机" scheme="http://blog.lyogvce.me/tags/%E8%A3%85%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>ssh 非交互式远程执行命令</title>
    <link href="http://blog.lyogvce.me/2016-11/SSH-Remote-Command-Execution-Non-Interactive.html"/>
    <id>http://blog.lyogvce.me/2016-11/SSH-Remote-Command-Execution-Non-Interactive.html</id>
    <published>2016-11-20T16:00:00.000Z</published>
    <updated>2017-07-16T02:26:59.323Z</updated>
    
    <content type="html"><![CDATA[<p><strong>待整理</strong></p>
<p>非交互式在远程主机上执行命令或者脚本可以帮助我们快速完成一些任务. 比如, 在集群环境中, 同时在各个结点上的日志文件中查询特定的关键字</p>
<p>ssh 命令格式如下:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ssh [-1246AaCfgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]</div><div class="line">    [-D [bind_address:]port] [-e escape_char] [-F configfile]</div><div class="line">    [-I pkcs11] [-i identity_file]</div><div class="line">    [-L [bind_address:]port:host:hostport]</div><div class="line">    [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]</div><div class="line">    [-R [bind_address:]port:host:hostport] [-S ctl_path]</div><div class="line">    [-W host:port] [-w local_tun[:remote_tun]]</div><div class="line">    [user@]hostname [<span class="built_in">command</span>]</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>主要参数说明:<br>-l 指定登入用户<br>-p 设置端口号<br>-f 后台运行, 并推荐加上 -n 参数<br>-n 将标准输入重定向到 /dev/null, 防止读取标准输入<br>-N 不执行远程命令, 只做端口转发<br>-q 安静模式, 忽略一切对话和错误提示<br>-T 禁用伪终端配置</p>
<p>ssh 执行远程命令格式:</p>
<p>ssh [options][remote host][command]</p>
<p>假设远程服务器 IP 是 192.168.110.34</p>
<p>例: 查看远程服务器的 cpu 信息</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">www-online@onlinedev01:~$ ssh -l www-online 192.168.110.34 <span class="string">"cat /proc/cpuinfo"</span></div><div class="line">www-online@192.168.110.34<span class="string">'s password:</span></div><div class="line">processor       : 0</div><div class="line">vendor_id       : GenuineIntel</div><div class="line">cpu family      : 6</div><div class="line">model           : 26</div><div class="line">model name      : Intel(R) Xeon(R) CPU           E5506  @ 2.13GHz</div><div class="line">stepping        : 5</div><div class="line">cpu MHz         : 2128.000</div><div class="line">cache size      : 4096 KB</div><div class="line">fpu             : yes</div><div class="line">fpu_exception   : yes</div><div class="line">cpuid level     : 11</div><div class="line">wp              : yes</div><div class="line">flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss syscall nx rdtscp lm constant_tsc arch_perfmon pebs bts rep_good xtopology tsc_reliable nonstop_tsc aperfmperf pni ssse3 cx16 sse4_1 sse4_2 popcnt hypervisor lahf_lm</div><div class="line">bogomips        : 4256.00</div><div class="line">clflush size    : 64</div><div class="line">cache_alignment : 64</div><div class="line">address sizes   : 40 bits physical, 48 bits virtual</div><div class="line">power management:</div><div class="line"></div><div class="line">processor       : 1</div><div class="line">vendor_id       : GenuineIntel</div><div class="line">cpu family      : 6</div><div class="line">model           : 26</div><div class="line">model name      : Intel(R) Xeon(R) CPU           E5506  @ 2.13GHz</div><div class="line">stepping        : 5</div><div class="line">cpu MHz         : 2128.000</div><div class="line">cache size      : 4096 KB</div><div class="line">fpu             : yes</div><div class="line">fpu_exception   : yes</div><div class="line">cpuid level     : 11</div><div class="line">wp              : yes</div><div class="line">flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss syscall nx rdtscp lm constant_tsc arch_perfmon pebs bts rep_good xtopology tsc_reliable nonstop_tsc aperfmperf pni ssse3 cx16 sse4_1 sse4_2 popcnt hypervisor lahf_lm</div><div class="line">bogomips        : 4260.80</div><div class="line">clflush size    : 64</div><div class="line">cache_alignment : 64</div><div class="line">address sizes   : 40 bits physical, 48 bits virtual</div><div class="line">power management:</div></pre></td></tr></table></figure>
<p>例: 执行远程服务器的 sh 文件<br>首先在远程服务器的 /home/www-online/ 下创建一个 uptimelog.sh 脚本</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line">uptime &gt;&gt; <span class="string">'uptime.log'</span></div><div class="line"></div><div class="line"><span class="built_in">exit</span> 0</div></pre></td></tr></table></figure>
<p>使用 chmod 增加可执行权限</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod u+x uptimelog.sh</div></pre></td></tr></table></figure>
<p>在本地调用远程的 uptimelog.sh</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -l www-online 192.168.110.34 <span class="string">"/home/www-online/uptimelog.sh"</span></div></pre></td></tr></table></figure>
<p>执行完成后, 在远程服务器的 /home/www-online/ 中会看到 uptime.log 文件, 显示 uptime 内容</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">www-online@nmgwww34:~$ tail -f uptime.log</div><div class="line">21:07:34 up 288 days,  8:07,  1 user,  load average: 0.05, 0.19, 0.31</div></pre></td></tr></table></figure>
<p>例: 执行远程后台运行 sh<br>首先把 uptimelog.sh 修改一下, 修改成循环执行的命令。作用是每一秒把 uptime 写入 uptime.log</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line"><span class="keyword">while</span> :</div><div class="line"><span class="keyword">do</span></div><div class="line">  uptime &gt;&gt; <span class="string">'uptime.log'</span></div><div class="line">  sleep 1</div><div class="line"><span class="keyword">done</span></div><div class="line"></div><div class="line"><span class="built_in">exit</span> 0</div></pre></td></tr></table></figure>
<p>我们需要这个 sh 在远程服务器以后台方式运行, 命令如下:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">www-online@onlinedev01:~$ ssh -l www-online 192.168.110.34 <span class="string">"/home/www-online/uptimelog.sh &amp;"</span></div><div class="line">www-online@192.168.110.34<span class="string">'s password:</span></div></pre></td></tr></table></figure>
<p>输入密码后, 发现一直停住了, 而在远程服务器可以看到, 程序已经以后台方式运行了。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">www-online@nmgwww34:~$ ps aux|grep uptimelog.sh</div><div class="line">1007     20791  0.0  0.0  10720  1432 ?        S    21:25   0:00 /bin/bash /home/www-online/uptimelog.sh</div></pre></td></tr></table></figure>
<p>原因是因为 uptimelog.sh 一直在运行, 并没有任何返回, 因此调用方一直处于等待状态。<br>我们先 kill 掉远程服务器的 uptimelog.sh 进程, 然后对应此问题进行解决。</p>
<p>ssh 调用远程命令后不能自动退出解决方法<br>可以将标准输出与标准错误输出重定向到 /dev/null, 这样就不会一直处于等待状态。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">www-online@onlinedev01:~$ ssh -l www-online 192.168.110.34 <span class="string">"/home/www-online/uptimelog.sh &gt; /dev/null 2&gt;&amp;1 &amp;"</span></div><div class="line">www-online@192.168.110.34<span class="string">'s password:</span></div><div class="line">www-online@onlinedev01:~$</div></pre></td></tr></table></figure>
<p>但这个 ssh 进程会一直运行在后台, 浪费资源, 因此我们需要自动清理这些进程。</p>
<p>实际上, 想 ssh 退出, 我们可以在 ssh 执行完成后 kill 掉 ssh 这个进程来实现。<br>首先, 创建一个 sh 执行 ssh 的命令, 这里需要用到 ssh 的 -f 与 -n 参数, 因为我们需要 ssh 也以后台方式运行, 这样才可以获取到进程号进行 kill 操作。<br>创建 ssh_uptimelog.sh, 脚本如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line">ssh -f -n -l www-online 192.168.110.34 <span class="string">"/home/www-online/uptimelog.sh &amp;"</span> <span class="comment"># 后台运行 ssh</span></div><div class="line"></div><div class="line">pid=$(ps aux | grep <span class="string">"ssh -f -n -l www-online 192.168.110.34 /home/www-online/uptimelog.sh"</span> | awk <span class="string">'&#123;print $2&#125;'</span> | sort -n | head -n 1) <span class="comment"># 获取进程号</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"ssh command is running, pid:<span class="variable">$&#123;pid&#125;</span>"</span></div><div class="line"></div><div class="line">sleep 3 &amp;&amp; <span class="built_in">kill</span> <span class="variable">$&#123;pid&#125;</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">"ssh command is complete"</span> <span class="comment"># 延迟 3 秒后执行 kill 命令, 关闭 ssh 进程, 延迟时间可以根据调用的命令不同调整</span></div><div class="line"></div><div class="line"><span class="built_in">exit</span> 0</div></pre></td></tr></table></figure>
<p>可以看到, 3 秒后会自动退出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">www-online@onlinedev01:~$ ./ssh_uptimelog.sh</div><div class="line">www-online@192.168.110.34<span class="string">'s password:</span></div><div class="line">ssh command is running, pid:10141</div><div class="line">ssh command is complete</div><div class="line">www-online@onlinedev01:~$</div></pre></td></tr></table></figure>
<p>然后查看远程服务器, 可以见到 uptimelog.sh 在后台正常执行。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">www-online@nmgwww34:~$ ps aux|grep uptime</div><div class="line">1007     28061  0.1  0.0  10720  1432 ?        S    22:05   0:00 /bin/bash /home/www-online/uptimelog.sh</div></pre></td></tr></table></figure>
<p>查看 uptime.log, 每秒都有 uptime 数据写入。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">www-online@nmgwww34:~$ tail -f uptime.log</div><div class="line">22:05:44 up 288 days,  9:05,  1 user,  load average: 0.01, 0.03, 0.08</div><div class="line">22:05:45 up 288 days,  9:05,  1 user,  load average: 0.01, 0.03, 0.08</div><div class="line">22:05:46 up 288 days,  9:05,  1 user,  load average: 0.01, 0.03, 0.08</div><div class="line">22:05:47 up 288 days,  9:05,  1 user,  load average: 0.01, 0.03, 0.08</div><div class="line">22:05:48 up 288 days,  9:05,  1 user,  load average: 0.01, 0.03, 0.08</div></pre></td></tr></table></figure>
<p>通过 SSH 命令远程执行命令首先需要建立相关主机间的信任关系 (无密码登录). 否则, 在执行命令前 SSH 命令会提示你输入远程主机的密码, 这就产生了系统与人的交互, 不利于脚本的自动化. 建立主机间信任关系的方法如下:</p>
<p>假设我们有两台主机. 主机名分别为 linuxa 和 linuxb. 首先在 linuxa 上以当前用户运行如下命令生成本主机的公钥和私钥文件:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa</div></pre></td></tr></table></figure>
<p>上述命令执行后, 隐藏目录~/.ssh 下会出现两个文件: id_rsa 和 id_rsa.pub. 其中, id_rsa.pub 为公钥文件. 将该文件的内容追加到对端主机 linuxb 上~/.ssh 目录下的 authorized_keys 文件中. 若该文件不存在, 可自行创建之. 下面是一个 id_rsa.pub 文件示例的文件内容:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAtbW/vKjrIkTfFjSJP9FyVb3kQStc31oBuiKVaCZzoejxSM2+ck6CB09l4BoFujpI0+omL4NptxkEAgkCGnMco2yXrVSOqhqyaQV2BnDPkyMoEq2MGB9hSc9xQKa+Q== viscent@viscent</div></pre></td></tr></table></figure>
<p>接下来, 就可以在不输入密码的情况下在远程主机私执行命令了. 命令格式如下:</p>
<p>ssh 远程用户名 @远程主机 IP 地址 ‘远程命令或者脚本’</p>
<p>比如,</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh userA@192.168.0.6 <span class="string">'hostname'</span></div></pre></td></tr></table></figure>
<p>上述命令执行后, 终端输出的是对端主机的主机名, 而不是你当前登录的主机的主机名. 说明 hostname 这个命令其实是在对端主机上运行的.</p>
<p>若要远程执行脚本, 只需要将上面的命令的第三个参数改为要执行的远程脚本的文件名全称即可. 比如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh userA@192.168.0.6 <span class="string">'/home/userA/script/test.sh'</span></div></pre></td></tr></table></figure>
<p>shell 远程执行: 经常需要远程到其他节点上执行一些 shell 命令, 如果分别 ssh 到每台主机上再去执行很麻烦, 因此能有个集中管理的方式就好了. 一下介绍两种 shell 命令远程执行的方法.</p>
<p>前提条件: 配置 ssh 免密码登陆</p>
<p>*. 对于简单的命令: 如果是简单执行几个命令, 则:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh user@remoteNode <span class="string">"cd /home ; ls"</span></div></pre></td></tr></table></figure>
<p>基本能完成常用的对于远程节点的管理了, 几个注意的点:</p>
<ol>
<li>双引号, 必须有. 如果不加双引号, 第二个 ls 命令在本地执行</li>
<li>分号, 两个命令之间用分号隔开</li>
</ol>
<p>*. 对于脚本的方式:<br>　　有些远程执行的命令内容较多, 单一命令无法完成, 考虑脚本方式实现:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line">ssh user@remoteNode &gt; /dev/null 2&gt;&amp;1 &lt;&lt; eeooff</div><div class="line"><span class="built_in">cd</span> /home</div><div class="line">touch abcdefg.txt</div><div class="line"><span class="built_in">exit</span></div><div class="line">eeooff</div><div class="line"><span class="built_in">echo</span> <span class="keyword">done</span>!</div></pre></td></tr></table></figure>
<p>远程执行的内容在 “&lt;&lt; eeooff” 至 “eeooff” 之间, 在远程机器上的操作就位于其中, 注意的点:</p>
<p>&lt;&lt; eeooff, ssh 后直到遇到 eeooff 这样的内容结束, eeooff 可以随便修改成其他形式.<br>重定向目的在于不显示远程的输出了<br>在结束前, 加 exit 退出远程节点</p>
<p><strong>需要特别注意的是: 当远程脚本中使用了一些命令, 而这些命令被 Shell 解析器的识别依赖于 PATH 环境变量时, 该脚本需要在其第一行中包含执行 profile 文件的命令. 比如, 在 Bash 中, 该脚本的第一行为:</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">source</span> ~/.bashrc</div></pre></td></tr></table></figure>
<p>否则, 远程脚本可能报一些命令无法找到的错误.</p>
<p>补充:</p>
<p>配置 hadoop 伪分布式的话, 需要本机对本机能够进行免密码访问, 直接将公钥文件 id_rsa.pub 的文件追加到 authorized_keys 中即可</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install ssh</div><div class="line"><span class="built_in">cd</span> ~                                             <span class="comment"># 最好在要配置的用户的家目录下</span></div><div class="line">ssh-keygen -t rsa                                <span class="comment"># 生成 rsa 密钥对, 也可以选 dsa</span></div><div class="line">cp ./.ssh/id_rsa.pub ./.ssh/authorized_keys      <span class="comment"># id_rsa.pub 是公钥, id_rsa 是私钥</span></div><div class="line">ssh localhost                                    <span class="comment"># 验证, 第一次要输入'yes'确认加入 the list of known hosts</span></div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/fdipzone/article/details/23000201" target="_blank" rel="external">http://blog.csdn.net/fdipzone/article/details/23000201</a><br><a href="http://www.cnblogs.com/ilfmonday/p/ShellRemote.html" target="_blank" rel="external">http://www.cnblogs.com/ilfmonday/p/ShellRemote.html</a><br><a href="http://viscent.iteye.com/blog/1706691" target="_blank" rel="external">http://viscent.iteye.com/blog/1706691</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;待整理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;非交互式在远程主机上执行命令或者脚本可以帮助我们快速完成一些任务. 比如, 在集群环境中, 同时在各个结点上的日志文件中查询特定的关键字&lt;/p&gt;
&lt;p&gt;ssh 命令格式如下:&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ssh [-1246AaCfgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [-D [bind_address:]port] [-e escape_char] [-F configfile]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [-I pkcs11] [-i identity_file]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [-L [bind_address:]port:host:hostport]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [-R [bind_address:]port:host:hostport] [-S ctl_path]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [-W host:port] [-w local_tun[:remote_tun]]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [user@]hostname [&lt;span class=&quot;built_in&quot;&gt;command&lt;/span&gt;]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.lyogvce.me/categories/Linux/"/>
    
      <category term="运维" scheme="http://blog.lyogvce.me/categories/Linux/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="运维" scheme="http://blog.lyogvce.me/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="ssh" scheme="http://blog.lyogvce.me/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>ps 配合 kill 使用</title>
    <link href="http://blog.lyogvce.me/2016-10/Command-Usage-ps-With-kill.html"/>
    <id>http://blog.lyogvce.me/2016-10/Command-Usage-ps-With-kill.html</id>
    <published>2016-10-30T16:00:00.000Z</published>
    <updated>2017-07-16T02:26:59.186Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常规篇"><a href="#常规篇" class="headerlink" title="常规篇"></a>常规篇</h2><p>首先, 用 ps 查看进程, 方法如下:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ ps -ef</div><div class="line">……</div><div class="line">will       1822     1  0 11:38 ?        00:00:49 gnome-terminal</div><div class="line">will       1823  1822  0 11:38 ?        00:00:00 gnome-pty-helper</div><div class="line">will       1824  1822  0 11:38 pts/0    00:00:02 bash</div><div class="line">will       1827     1  4 11:38 ?        00:26:28 /usr/lib/firefox-3.6.18/firefox-bin</div><div class="line">will       1857  1822  0 11:38 pts/1    00:00:00 bash</div><div class="line">will       1880  1619  0 11:38 ?        00:00:00 update-notifier</div><div class="line">……</div><div class="line">will      11946  1824  0 21:41 pts/0    00:00:00 ps -ef</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>或者:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ ps -aux</div><div class="line">……</div><div class="line">will       1822  0.1  0.8  58484 18152 ?        Sl   11:38   0:49 gnome-terminal</div><div class="line">will       1823  0.0  0.0   1988   712 ?        S    11:38   0:00 gnome-pty-helper</div><div class="line">will       1824  0.0  0.1   6820  3776 pts/0    Ss   11:38   0:02 bash</div><div class="line">will       1827  4.3  5.8 398196 119568 ?       Sl   11:38  26:13 /usr/lib/firefox-3.6.18/firefox-bin</div><div class="line">will       1857  0.0  0.1   6688  3644 pts/1    Ss   11:38   0:00 bash</div><div class="line">will       1880  0.0  0.6  41536 12620 ?        S    11:38   0:00 update-notifier</div><div class="line">……</div><div class="line">will      11953  0.0  0.0   2716  1064 pts/0    R+   21:42   0:00 ps -aux</div></pre></td></tr></table></figure>
<p>此时如果我想杀了火狐的进程就在终端输入:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">kill</span> -9 1827</div></pre></td></tr></table></figure>
<p>其中 <code>-9</code> 指定了传递给进程的信号是 9, 即强制、尽快终止进程.<br>1827 则是上面 ps 查到的火狐的 PID.<br>简单吧, 但有个问题, 进程少了则无所谓, 进程多了, 就会觉得痛苦了, 无论是 <code>ps -ef</code> 还是 <code>ps -aux</code>, 每次都要在一大串进程信息里面查找到要杀的进程, 看的眼都花了.</p>
<h2 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h2><h3 id="改进-1"><a href="#改进-1" class="headerlink" title="改进 1"></a>改进 1</h3><p>把 ps 的查询结果通过管道给 grep 查找包含特定字符串的进程. 管道符 “|” 用来隔开两个命令, 管道符左边命令的输出会作为管道符右边命令的输入.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ps -ef | grep firefox</div><div class="line">will       1827     1  4 11:38 ?        00:27:33 /usr/lib/firefox-3.6.18/firefox-bin</div><div class="line">will      12029  1824  0 21:54 pts/0    00:00:00 grep --color=auto firefox</div></pre></td></tr></table></figure>
<p>这次就清爽了. 然后就是</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">kill</span> -9 1827</div></pre></td></tr></table></figure>
<p>还是嫌打字多?</p>
<h3 id="改进-2-使用-pgrep"><a href="#改进-2-使用-pgrep" class="headerlink" title="改进 2 - 使用 pgrep"></a>改进 2 - 使用 pgrep</h3><p>一看到 pgrep 首先会想到什么? 没错, grep! pgrep 的 p 表明了这个命令是专门用于进程查询的 grep.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ pgrep firefox</div><div class="line">1827</div></pre></td></tr></table></figure>
<p>看到了什么? 没错火狐的 PID, 接下来又要打字了:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">kill</span> -9 1827</div></pre></td></tr></table></figure>
<h3 id="改进-3-使用-pidof"><a href="#改进-3-使用-pidof" class="headerlink" title="改进 3 - 使用 pidof"></a>改进 3 - 使用 pidof</h3><p>看到 pidof 想到啥? 没错 pid of xx, 字面翻译过来就是 xx 的 PID.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ pidof firefox-bin</div><div class="line">1827</div></pre></td></tr></table></figure>
<p>和 pgrep 相比稍显不足的是, pidof 必须给出进程的全名. 然后就是老生常谈:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">kill</span> -9 1827</div></pre></td></tr></table></figure>
<p>无论使用 ps 然后慢慢查找进程 PID 还是用 grep 查找包含相应字符串的进程, 亦或者用 pgrep 直接查找包含相应字符串的进程 pid, 然后手动输入给 kill 杀掉, 都稍显麻烦. 有没有更方便的方法? 有!</p>
<h3 id="改进-4"><a href="#改进-4" class="headerlink" title="改进 4"></a>改进 4</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -ef | grep firefox | grep -v grep | cut -c 9-15 | xargs <span class="built_in">kill</span> -9</div></pre></td></tr></table></figure>
<p>说明:<br>“grep firefox” 的输出结果是, 所有含有关键字 “firefox” 的进程.<br>“grep -v grep” 是在列出的进程中去除含有关键字 “grep” 的进程.<br>“cut -c 9-15” 是截取输入行的第 9 个字符到第 15 个字符, 而这正好是进程号 PID.<br>“xargs kill -9” 中的 xargs 命令是用来把前面命令的输出结果 (PID) 作为 “kill -9” 命令的参数, 并执行该命令. “kill -9” 会强行杀掉指定进程.<br>难道你不想抱怨点什么? 没错太长了</p>
<h3 id="改进-5"><a href="#改进-5" class="headerlink" title="改进 5"></a>改进 5</h3><p>知道 pgrep 和 pidof 两个命令, 干嘛还要打那么长一串!</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pgrep firefox | xargs <span class="built_in">kill</span> -9</div></pre></td></tr></table></figure>
<h3 id="改进-6"><a href="#改进-6" class="headerlink" title="改进 6"></a>改进 6</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ps -ef | grep firefox | awk <span class="string">'&#123;print $2&#125;'</span> | xargs <span class="built_in">kill</span> -9</div><div class="line"><span class="built_in">kill</span>: No such process</div></pre></td></tr></table></figure>
<p>有一个比较郁闷的地方, 进程已经正确找到并且终止了, 但是执行完却提示找不到进程.<br>其中 awk ‘{print $2}’ 的作用就是打印 (print) 出第二列的内容. 根据常规篇, 可以知道 ps 输出的第二列正好是 PID. 就把进程相应的 PID 通过 xargs 传递给 kill 作参数, 杀掉对应的进程.</p>
<h3 id="改进-7"><a href="#改进-7" class="headerlink" title="改进 7"></a>改进 7</h3><p>难道每次都要调用 xargs 把 PID 传递给 kill? 答案是否定的:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">kill</span> -9 `ps -aux | grep firefox | awk <span class="string">'&#123;print $2&#125;'</span>`</div></pre></td></tr></table></figure>
<h3 id="改进-8"><a href="#改进-8" class="headerlink" title="改进 8"></a>改进 8</h3><p>没错, 命令依然有点长, 换成 pgrep.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">kill</span> -9 `pgrep firefox`</div></pre></td></tr></table></figure>
<h3 id="改进-9-pkill"><a href="#改进-9-pkill" class="headerlink" title="改进 9 - pkill"></a>改进 9 - pkill</h3><p>看到 pkill 想到了什么? 没错 pgrep 和 kill! pkill = pgrep + kill.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pkill -9 firefox</div></pre></td></tr></table></figure>
<h3 id="改进-10-killall"><a href="#改进-10-killall" class="headerlink" title="改进 10 - killall"></a>改进 10 - killall</h3><p>killall 和 pkill 是相似的, 不过如果给出的进程名不完整, killall 会报错. pkill 或者 pgrep 只要给出进程名的一部分就可以终止进程.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">killall -9 firefox</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ps -ef                         <span class="comment"># *</span></div><div class="line">ps -aux                        <span class="comment"># *</span></div><div class="line">pgrep firefox                  <span class="comment"># *</span></div><div class="line">pidof firefox-bin</div><div class="line">pgrep firefox | xargs <span class="built_in">kill</span> -9</div><div class="line"><span class="built_in">kill</span> -9 `pgrep firefox`        <span class="comment"># *</span></div><div class="line">pkill -9 firefox               <span class="comment"># *</span></div><div class="line">killall -9 firefox             <span class="comment"># *</span></div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/a351945755/article/details/20210087" target="_blank" rel="external">http://blog.csdn.net/a351945755/article/details/20210087</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;常规篇&quot;&gt;&lt;a href=&quot;#常规篇&quot; class=&quot;headerlink&quot; title=&quot;常规篇&quot;&gt;&lt;/a&gt;常规篇&lt;/h2&gt;&lt;p&gt;首先, 用 ps 查看进程, 方法如下:&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ ps -ef&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;……&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;will       1822     1  0 11:38 ?        00:00:49 gnome-terminal&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;will       1823  1822  0 11:38 ?        00:00:00 gnome-pty-helper&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;will       1824  1822  0 11:38 pts/0    00:00:02 bash&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;will       1827     1  4 11:38 ?        00:26:28 /usr/lib/firefox-3.6.18/firefox-bin&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;will       1857  1822  0 11:38 pts/1    00:00:00 bash&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;will       1880  1619  0 11:38 ?        00:00:00 update-notifier&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;……&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;will      11946  1824  0 21:41 pts/0    00:00:00 ps -ef&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.lyogvce.me/categories/Linux/"/>
    
      <category term="Shell" scheme="http://blog.lyogvce.me/categories/Linux/Shell/"/>
    
    
      <category term="Shell" scheme="http://blog.lyogvce.me/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>获取脚本所在绝对目录</title>
    <link href="http://blog.lyogvce.me/2016-10/Get-Absolute-Path-Of-Script.html"/>
    <id>http://blog.lyogvce.me/2016-10/Get-Absolute-Path-Of-Script.html</id>
    <published>2016-10-25T16:00:00.000Z</published>
    <updated>2017-07-16T02:26:59.255Z</updated>
    
    <content type="html"><![CDATA[<p>因为脚本可能是在别的目录里调用的, 甚至是在子 shell 中调用的, 所以仅 <code>pwd</code> 是不行的</p>
<p>应该用它</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curpath=$(<span class="built_in">cd</span> `dirname <span class="variable">$0</span>`; <span class="built_in">pwd</span>)</div></pre></td></tr></table></figure>
<a id="more"></a>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为脚本可能是在别的目录里调用的, 甚至是在子 shell 中调用的, 所以仅 &lt;code&gt;pwd&lt;/code&gt; 是不行的&lt;/p&gt;
&lt;p&gt;应该用它&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;curpath=$(&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; `dirname &lt;span class=&quot;variable&quot;&gt;$0&lt;/span&gt;`; &lt;span class=&quot;built_in&quot;&gt;pwd&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.lyogvce.me/categories/Linux/"/>
    
      <category term="Shell" scheme="http://blog.lyogvce.me/categories/Linux/Shell/"/>
    
    
      <category term="Shell" scheme="http://blog.lyogvce.me/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux 下 SVN 服务器搭建</title>
    <link href="http://blog.lyogvce.me/2016-10/Build-Svn-Server-On-Linux.html"/>
    <id>http://blog.lyogvce.me/2016-10/Build-Svn-Server-On-Linux.html</id>
    <published>2016-10-24T16:00:00.000Z</published>
    <updated>2017-07-16T02:26:58.980Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲解 Linux 下 SVN 服务器的搭建: 基本的单仓库 SVN 服务器, 支持 HTTP 协议的 SVN 服务器, 多仓库的 SVN 服务器。</p>
<a id="more"></a>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>安装步骤如下:</p>
<ol>
<li><strong>yum install subversion</strong></li>
<li><p>查看安装版本 <strong>svnserve –version</strong></p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">svnserve, 版本 1.7.14 (r1542130)</div><div class="line">编译于 Nov 20 2015, 19:25:09</div><div class="line"></div><div class="line">版权所有 (C) 2013 Apache 软件基金会.</div><div class="line">此软件包含了许多人的贡献, 请查看文件 NOTICE 以获得更多信息.</div><div class="line">Subversion 是开放源代码软件, 请参阅 http://subversion.apache.org/ 站点.</div><div class="line"></div><div class="line">下列版本库后端(FS) 模块可用:</div><div class="line"></div><div class="line">* fs_base : 模块只能操作 BDB 版本库.</div><div class="line">* fs_fs : 模块与文本文件 (FSFS) 版本库一起工作.</div><div class="line"></div><div class="line">Cyrus SASL 认证可用.</div></pre></td></tr></table></figure>
</li>
<li><p>创建 svn 版本库目录 <strong>mkdir -p /var/svn/project1</strong></p>
</li>
<li><p>创建版本库 <strong>svnadmin create /var/svn/project1</strong></p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[will@master-cent7-1:/var/svn/project1]$&gt;ll</div><div class="line">总用量 16</div><div class="line">drwxr-xr-x. 2 root root   51 10月 24 09:28 conf</div><div class="line">drwxr-sr-x. 6 root root 4096 10月 24 09:12 db</div><div class="line">-r--r--r--. 1 root root    2 10月 24 09:12 format</div><div class="line">drwxr-xr-x. 2 root root 4096 10月 24 09:12 hooks</div><div class="line">drwxr-xr-x. 2 root root   39 10月 24 09:12 locks</div><div class="line">-rw-r--r--. 1 root root  229 10月 24 09:12 README.txt</div></pre></td></tr></table></figure>
</li>
<li><p>进入 conf 目录(该 svn 版本库配置文件) <strong>cd conf/</strong></p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">authz           文件是权限控制文件</div><div class="line">passwd          是帐号密码文件</div><div class="line">svnserve.conf   svn 服务配置文件</div></pre></td></tr></table></figure>
</li>
<li><p>设置帐号密码, 在文件 passwd 中: 在[users]块中添加用户和密码, 格式: <code>帐号=密码</code>, 如 <code>ljc=ljc</code></p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[will@master-cent7-1:/var/svn/project1/conf]$&gt;vim passwd</div><div class="line"><span class="comment">### This file is an example password file for svnserve.</span></div><div class="line"><span class="comment">### Its format is similar to that of svnserve.conf. As shown in the</span></div><div class="line"><span class="comment">### example below it contains one section labelled [users].</span></div><div class="line"><span class="comment">### The name and password for each user follow, one account per line.</span></div><div class="line"></div><div class="line">[users]</div><div class="line"><span class="comment"># harry = harryssecret</span></div><div class="line"><span class="comment"># sally = sallyssecret</span></div><div class="line">ljc=ljc</div></pre></td></tr></table></figure>
</li>
<li><p>设置权限: 在文件 authz 添加如下代码:</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[groups]</div><div class="line">admin = user1, user2</div><div class="line"></div><div class="line">[/]</div><div class="line">@admin = rw  <span class="comment"># admin 用户组对当前版本库的根目录有读写权限</span></div><div class="line">ljc = rw</div><div class="line">* =          <span class="comment"># 其他用户权限为空</span></div></pre></td></tr></table></figure>
</li>
<li><p>修改 svnserve.conf 文件:　打开下面的几个注释</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">anon-access = none    <span class="comment"># 匿名用户无权限</span></div><div class="line">auth-access = write   <span class="comment"># 授权用户可写</span></div><div class="line">password-db = passwd  <span class="comment"># 使用哪个文件作为账号文件</span></div><div class="line">authz-db = authz      <span class="comment"># 使用哪个文件作为权限文件</span></div><div class="line">realm = project1      <span class="comment"># 认证空间名</span></div></pre></td></tr></table></figure>
</li>
<li><p>启动 svn</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">svnserve -d --listen-port 3690 -r /var/svn/project1  <span class="comment"># 用 svn://192.168.125.171[:3690] 打开 /project1</span></div></pre></td></tr></table></figure>
<p> or</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">svnserve -d --listen-port 3690 -r /var/svn           <span class="comment"># 用 svn://192.168.125.171[:3690]/project1 打开 /project1</span></div></pre></td></tr></table></figure>
<p> 停止 svn 命令</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">killall svnserve</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><h3 id="1-搭建支持-HTTP-协议的-svn-服务器"><a href="#1-搭建支持-HTTP-协议的-svn-服务器" class="headerlink" title="1. 搭建支持 HTTP 协议的 svn 服务器"></a>1. 搭建支持 HTTP 协议的 svn 服务器</h3><p><a href="http://www.centoscn.com/CentosServer/ftp/2015/0620/5701.html" target="_blank" rel="external">http://www.centoscn.com/CentosServer/ftp/2015/0620/5701.html</a></p>
<h3 id="2-配置-svn-服务器开机启动"><a href="#2-配置-svn-服务器开机启动" class="headerlink" title="2. 配置 svn 服务器开机启动"></a>2. 配置 svn 服务器开机启动</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl <span class="built_in">enable</span> svnserve.service</div></pre></td></tr></table></figure>
<h3 id="3-多仓库"><a href="#3-多仓库" class="headerlink" title="3. 多仓库"></a>3. 多仓库</h3><h4 id="两个仓库"><a href="#两个仓库" class="headerlink" title="两个仓库"></a>两个仓库</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">svnadmin create /var/svn/project1</div><div class="line">svnadmin create /var/svn/project2</div></pre></td></tr></table></figure>
<h4 id="共用一份-authz-和-passwd-文件"><a href="#共用一份-authz-和-passwd-文件" class="headerlink" title="共用一份 authz 和 passwd 文件"></a>共用一份 authz 和 passwd 文件</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /var/svn/project1/conf</div><div class="line">cp authz passwd /var/svn</div></pre></td></tr></table></figure>
<p>passwd 的填写见 6.</p>
<p>authz 修改如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[groups]</div><div class="line">admin = user1, user2</div><div class="line">group1 = abc,cde</div><div class="line">group2 = cde,ljk</div><div class="line"></div><div class="line">[project1:/] <span class="comment"># 仓库 1 与仓库 2 权限管理不同</span></div><div class="line">@group1 = rw <span class="comment"># group1 用户组对 project1 项目的根目录有读写权限</span></div><div class="line">ljc = rw</div><div class="line">* =          <span class="comment"># 其他用户权限为空</span></div><div class="line"></div><div class="line">[project2:/]</div><div class="line">@group2 = rw <span class="comment"># group2 用户组对 project2 项目的根目录有读写权限</span></div><div class="line">ljc = rw</div><div class="line">* =</div></pre></td></tr></table></figure>
<p>若是多个仓库的认证权限一样, 可以这样(若指定了仓库独有的权限就会 <strong>屏蔽</strong> 这一条)</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[/]          <span class="comment"># admin 用户组对 **所有未指定独有权限的项目的根目录** 有读写权限</span></div><div class="line">@admin = rw</div></pre></td></tr></table></figure>
<h4 id="svnserve-conf-文件的填写"><a href="#svnserve-conf-文件的填写" class="headerlink" title="svnserve.conf 文件的填写"></a>svnserve.conf 文件的填写</h4><p>project1 的 svnserve.conf 文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">anon-access = none          <span class="comment"># 匿名用户无权限</span></div><div class="line">auth-access = write         <span class="comment"># 授权用户可写</span></div><div class="line">password-db = ../../passwd  <span class="comment"># 与 project2 共用一个</span></div><div class="line">authz-db = ../../authz      <span class="comment"># 与 project2 共用一个</span></div><div class="line">realm = project1            <span class="comment"># 认证空间名</span></div></pre></td></tr></table></figure>
<p>project2 的 svnserve.conf 文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">anon-access = none          <span class="comment"># 匿名用户无权限</span></div><div class="line">auth-access = write         <span class="comment"># 授权用户可写</span></div><div class="line">password-db = ../../passwd  <span class="comment"># 与 project1 共用一个</span></div><div class="line">authz-db = ../../authz      <span class="comment"># 与 project1 共用一个</span></div><div class="line">realm = project2            <span class="comment"># 认证空间名</span></div></pre></td></tr></table></figure>
<p>####　启动 svn</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">svnserve -d --listen-port 3690 -r /var/svn/</div></pre></td></tr></table></figure>
<p>用 svn://192.168.125.171[:3690]/project1 访问 /project1</p>
<p>用 svn://192.168.125.171[:3690]/project2 访问 /project2</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文讲解 Linux 下 SVN 服务器的搭建: 基本的单仓库 SVN 服务器, 支持 HTTP 协议的 SVN 服务器, 多仓库的 SVN 服务器。&lt;/p&gt;
    
    </summary>
    
      <category term="版本管理" scheme="http://blog.lyogvce.me/categories/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    
      <category term="SVN" scheme="http://blog.lyogvce.me/categories/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/SVN/"/>
    
    
      <category term="SVN" scheme="http://blog.lyogvce.me/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7 配置服务随开机启动</title>
    <link href="http://blog.lyogvce.me/2016-10/Service-Start-On-Boot.html"/>
    <id>http://blog.lyogvce.me/2016-10/Service-Start-On-Boot.html</id>
    <published>2016-10-23T16:00:00.000Z</published>
    <updated>2017-07-16T02:26:59.288Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>法 1: <code>systemctl enable svnserve.service</code>, 参考 <a href="CentOS-7-Systemctl-Command.html">CentOS-7-Systemctl-Command</a></li>
<li>法 2: 写到 <code>/etc/rc.d/rc.local</code> 中</li>
</ul>
<a id="more"></a>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;法 1: &lt;code&gt;systemctl enable svnserve.service&lt;/code&gt;, 参考 &lt;a href=&quot;CentOS-7-Systemctl-Command.html&quot;&gt;CentOS-7-Systemctl-Command&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;法 2: 写到 &lt;code&gt;/etc/rc.d/rc.local&lt;/code&gt; 中&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.lyogvce.me/categories/Linux/"/>
    
      <category term="运维" scheme="http://blog.lyogvce.me/categories/Linux/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="运维" scheme="http://blog.lyogvce.me/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="CentOS" scheme="http://blog.lyogvce.me/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>ps 命令</title>
    <link href="http://blog.lyogvce.me/2016-10/Command-Usage-ps.html"/>
    <id>http://blog.lyogvce.me/2016-10/Command-Usage-ps.html</id>
    <published>2016-10-21T16:00:00.000Z</published>
    <updated>2017-07-16T02:26:59.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ps-命令是-Process-Status-的缩写"><a href="#ps-命令是-Process-Status-的缩写" class="headerlink" title="ps 命令是 Process Status 的缩写"></a>ps 命令是 Process Status 的缩写</h2><p>ps 命令列出的是执行 ps 命令的时刻的进程的快照, 相关命令: top | htop | pstree</p>
<a id="more"></a>
<h2 id="linux-上进程有-5-种状态"><a href="#linux-上进程有-5-种状态" class="headerlink" title="linux 上进程有 5 种状态"></a>linux 上进程有 5 种状态</h2><ol>
<li>R TASK_RUNNING 可执行状态 正在运行或在运行队列中等待 - Linux 中 “运行” 和 “就绪” 都是 R</li>
<li>S TASK_INTERRUPTIBLE 可中断的睡眠状态<ol>
<li>在等待某事件的发生而被挂起</li>
<li>进程列表中的绝大多数进程都处于 S 状态 (除非机器的负载很高)</li>
</ol>
</li>
<li>D TASK_UNINTERRUPTIBLE 不可中断的睡眠状态<ol>
<li>不可中断指的并不是 CPU 不响应外部硬件的中断, 即是响应中断的</li>
<li>而是指进程不响应异步信号, 即 kill -9 杀不死!</li>
<li>D 状态总是非常短暂的 (一般是 IO), 通过 ps 命令基本上不可能捕捉到.</li>
</ol>
</li>
<li>T TASK_STOPPED or TASK_TRACED 暂停状态或跟踪状态 (如 gdb 中的断点跟踪)<ol>
<li>进程收到 SIGSTOP, SIGSTP, SIGTIN, SIGTOU 信号后停止运行</li>
<li>向 TASK_STOPPED 状态的进程发送一个 SIGCONT 信号, 可以让其从 TASK_STOPPED 状态恢复到 TASK_RUNNING 状态</li>
<li>处于 TASK_TRACED 状态的进程不能响应 SIGCONT 信号而被唤醒, 只能等到调试进程通过 ptrace 系统调用执行 PTRACE_CONT、PTRACE_DETACH 等操作, 或调试进程退出, 被调试的进程才能恢复 TASK_RUNNING 状态</li>
</ol>
</li>
<li>Z ASK_DEAD – EXIT_ZOMBIE 退出状态<ol>
<li>进程在退出的过程中, 处于 TASK_DEAD 状态, 但进程描述符存在, 直到父进程调用 wait4() 系统调用后释放</li>
<li>进程成为僵尸进程</li>
</ol>
</li>
</ol>
<h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><p>ps 命令支持三种语法格式</p>
<ul>
<li>UNIX 风格, 选项可以组合在一起, 选项前 <code>有 &quot;-&quot; 连字符</code></li>
<li>BSD 风格, 选项可以组合在一起, 选项前 <code>没有 &quot;-&quot; 连字符</code></li>
<li>GNU 风格的长选项, 选项前 <code>有两个 &quot;-&quot; 连字符</code></li>
</ul>
<p>可以混用 (?), 但可能有冲突, 我一般使用 UNIX 风格的 ps 命令</p>
<p>ps　[-aAcdefHjlmNVwy]<br>　　[acefhgLnrsSTuvxX]<br>　　[-C&lt;指令名称&gt;]<br>　　[-g&lt;群组名称&gt;][-G&lt;群组号码&gt;]<br>　　[-p&lt;程序识别码&gt;][p&lt;程序识别码&gt;]<br>　　[-u&lt;用户识别码&gt;][-U&lt;用户识别码&gt;][U&lt;用户名称&gt;]<br>　　[-s&lt;阶段作业&gt;]<br>　　[-t&lt;终端机编号&gt;][t&lt;终端机号码&gt;]<br>　　[-&lt;程序识别码&gt;]<br>　　[–group&lt;群组名称&gt;][-Group&lt;群组识别码&gt;]<br>　　[–pid&lt;程序识别码&gt;][–user&lt;用户名称&gt;][–User&lt;用户识别码&gt;]<br>　　[–sid&lt;阶段作业&gt;][–tty&lt;终端机编码&gt;][–rows&lt;显示列数&gt;]<br>　　[–cols&lt;每行字符数&gt;][–columns&lt;每列字符数&gt;][–cumulative][–deselect][–forest][–headers][–no-headers][–lines&lt;显示列数&gt;][–width&lt;每列字符数&gt;]<br>　　[–info][–version][–help]</p>
<ul>
<li>-a       显示所有终端机下执行的程序, 除了阶段作业领导者之外.</li>
<li>a        显示现行终端机下的所有程序, 包括其他用户的程序.</li>
<li>-e = -A  显示所有进程</li>
<li>-f       显示 UID,PPIP,C 与 STIME 栏位.</li>
<li>f = -H   以树状结构显示进程的层次</li>
<li>-g 或 -G &lt;群组识别码&gt; 列出属于该群组的程序的状况, 也可使用群组名称来指定.</li>
<li>-C       &lt;指令名称&gt; 列出指定指令的程序的状况</li>
<li>-j 或 j  采用工作控制的格式显示程序状况.</li>
<li>-l 或 l  详细格式</li>
<li>-o       用户自定义格式.</li>
<li>-p 123   指定 pid</li>
<li>-u abc   指定 username</li>
<li>u        以用户为主的格式来显示程序状况.</li>
<li>x        显示所有程序, 不以终端机来区分.</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ol>
<li><p>常用命令</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ps -ef</div><div class="line">ps -lA</div><div class="line">ps aux</div><div class="line">ps axjf</div></pre></td></tr></table></figure>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[will@willpc ~]$ ps aux</div><div class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME  COMMAND</div><div class="line">root         1  0.0  0.0 126804  7604 ?        Ss   11月19   1:09 /usr/lib/systemd/systemd --switched-root --system --deserialize 21</div><div class="line">root         2  0.0  0.0      0     0 ?        S    11月19   0:00 [kthreadd]</div><div class="line">root         3  0.1  0.0      0     0 ?        S    11月19  31:42 [ksoftirqd/0]</div><div class="line">root         7  0.0  0.0      0     0 ?        S    11月19   0:00 [migration/0]</div><div class="line">root         8  0.0  0.0      0     0 ?        S    11月19   0:00 [rcu_bh]</div><div class="line">root         9  0.0  0.0      0     0 ?        S    11月19   0:00 [rcuob/0]</div></pre></td></tr></table></figure>
</li>
<li><p>根据 CPU 使用来升序排序</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -aux --sort -pcpu | less</div></pre></td></tr></table></figure>
</li>
<li><p>根据 内存使用 来升序排序</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -aux --sort -pmem | less</div></pre></td></tr></table></figure>
</li>
<li><p>我们也可以将它们合并到一个命令, 并通过管道显示前 10 个结果:</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -aux --sort -pcpu,+pmem | head -n 10</div></pre></td></tr></table></figure>
</li>
<li><p>根据线程来过滤进程</p>
<p> 如果我们想知道特定进程的线程, 可以使用 -L 参数, 后面加上特定的 PID.</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -L 1213</div></pre></td></tr></table></figure>
</li>
<li><p>有时候我们希望以树形结构显示进程, 可以使用 -axjf 参数.</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -axjf</div></pre></td></tr></table></figure>
<p> 或者可以使用另一个命令.</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pstree</div></pre></td></tr></table></figure>
<p> 结果往往过长, 一般配合 more/less 和 grep 使用</p>
</li>
</ol>
<h2 id="ps-输出的-Head-标头-解释"><a href="#ps-输出的-Head-标头-解释" class="headerlink" title="ps 输出的 Head 标头 解释"></a>ps 输出的 Head 标头 解释</h2><ul>
<li>USER: 该 process 属于哪个使用者</li>
<li>PID : 该 process 的号码</li>
<li>%CPU: 该 process 使用掉的 CPU 资源百分比</li>
<li>%MEM: 该 process 所占用的物理内存百分比</li>
<li>VSZ : 该 process 使用掉的虚拟内存量 (Kbytes)</li>
<li>RSS : 该 process 占用的固定的内存量 (Kbytes)</li>
<li>TTY : 该 process 是在那个终端机上面运作, 若与终端机无关, 则显示 , 另外,  tty1-tty6 是本机上面的登入者程序, 若为 pts/0 等等的, 则表示为由网络连接进主机的程序</li>
<li>STAT: 该程序目前的状态, 主要的状态有:<ul>
<li>D 不可中断 Uninterruptible(usually IO)</li>
<li>R 正在运行, 或在队列中的进程</li>
<li>S 处于休眠状态</li>
<li>T 停止或被追踪</li>
<li>Z 僵尸进程</li>
<li>W 进入内存交换 (从内核 2.6 开始无效)</li>
<li>X 死掉的进程</li>
<li>&lt; 高优先级</li>
<li>n 低优先级</li>
<li>s 包含子进程</li>
<li>+ 位于后台的进程组</li>
</ul>
</li>
</ul>
<h2 id="制定格式输出来查看进程状态"><a href="#制定格式输出来查看进程状态" class="headerlink" title="制定格式输出来查看进程状态"></a>制定格式输出来查看进程状态</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -eo user,<span class="built_in">stat</span>..,cmd</div></pre></td></tr></table></figure>
<p>参数 -e 显示所有进程信息, -o 参数控制输出. pid, user 和 args 参数显示 PID, 运行应用的用户和运行参数.</p>
<ul>
<li>user 用户名</li>
<li>uid 用户号</li>
<li>pid 进程号</li>
<li>ppid 父进程号</li>
<li>size 内存大小, Kbytes 字节.</li>
<li>vsize 总虚拟内存大小, bytes 字节 (包含 code+data+stack)</li>
<li>share 总共享页数</li>
<li>nice 进程优先级 (缺省为 0, 最大为 -20)</li>
<li>priority(pri) 内核调度优先级</li>
<li>pmem 进程分享的物理内存数的百分比</li>
<li>trs 程序执行代码驻留大小</li>
<li>rss 进程使用的总物理内存数, Kbytes 字节</li>
<li>time 进程执行起到现在总的 CPU 暂用时间</li>
<li>stat 进程状态</li>
<li>cmd(args) 执行命令的简单格式</li>
</ul>
<p>例子:</p>
<p>查看当前系统进程的 uid,pid,stat,pri, 以 uid 号排序.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -eo pid,<span class="built_in">stat</span>,pri,uid –sort uid</div></pre></td></tr></table></figure>
<p>查看当前系统进程的 user,pid,stat,rss,args, 以 rss 排序.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -eo user,pid,<span class="built_in">stat</span>,rss,args –sort rss</div></pre></td></tr></table></figure>
<h2 id="使用-PS-实时监控进程状态"><a href="#使用-PS-实时监控进程状态" class="headerlink" title="使用 PS 实时监控进程状态"></a>使用 PS 实时监控进程状态</h2><p>ps 命令会显示你系统当前的进程状态, 但是这个结果是静态的.</p>
<p>当有一种情况, 我们需要像上面第四点中提到的通过 CPU 和内存的使用率来筛选进程, 并且我们希望结果能够每秒刷新一次. 为此, 我们可以将 ps 命令和 watch 命令结合起来.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">watch -n 1 <span class="string">'ps -aux --sort -pmem, -pcpu'</span></div></pre></td></tr></table></figure>
<p>如果输出太长, 我们也可以限制它, 比如前 20 条, 我们可以使用 head 命令来做到.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">watch -n 1 <span class="string">'ps -aux --sort -pmem, -pcpu | head 20'</span></div></pre></td></tr></table></figure>
<p>这里的动态查看并不像 top 或者 htop 命令一样美观. 但是使用 ps 的好处是你能够定义显示的字段, 还可以输出到文件方便日后分析.</p>
<p>举个例子, 如果你只需要看名为’pungki’用户的信息, 你可以使用下面的命令:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">watch -n 1 <span class="string">'ps -aux -U pungki u --sort -pmem, -pcpu | head 20'</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ps-命令是-Process-Status-的缩写&quot;&gt;&lt;a href=&quot;#ps-命令是-Process-Status-的缩写&quot; class=&quot;headerlink&quot; title=&quot;ps 命令是 Process Status 的缩写&quot;&gt;&lt;/a&gt;ps 命令是 Process Status 的缩写&lt;/h2&gt;&lt;p&gt;ps 命令列出的是执行 ps 命令的时刻的进程的快照, 相关命令: top | htop | pstree&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.lyogvce.me/categories/Linux/"/>
    
      <category term="Shell" scheme="http://blog.lyogvce.me/categories/Linux/Shell/"/>
    
    
      <category term="Shell" scheme="http://blog.lyogvce.me/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7 systemctl 使用</title>
    <link href="http://blog.lyogvce.me/2016-10/CentOS-7-Systemctl-Command.html"/>
    <id>http://blog.lyogvce.me/2016-10/CentOS-7-Systemctl-Command.html</id>
    <published>2016-10-20T16:00:00.000Z</published>
    <updated>2017-07-16T02:26:59.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>systemctl 是系统服务管理器命令, 它实际上将 service 和 chkconfig 这两个命令组合到一起</p>
<a id="more"></a>
<h2 id="systemctl-命令格式"><a href="#systemctl-命令格式" class="headerlink" title="systemctl 命令格式"></a>systemctl 命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl [OPTIONS...]  &#123;COMMAND&#125;...</div></pre></td></tr></table></figure>
<h2 id="systemctl-示例"><a href="#systemctl-示例" class="headerlink" title="systemctl 示例"></a>systemctl 示例</h2><p>以 nginx 服务为例, 实现停止、启动、重启的动作如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">systemctl stop    nginx.service      <span class="comment"># 停止</span></div><div class="line">systemctl start   nginx.service      <span class="comment"># 启动</span></div><div class="line">systemctl restart nginx.service      <span class="comment"># 重启</span></div><div class="line">systemctl status  nginx.service      <span class="comment"># 检查服务状态</span></div><div class="line">systemctl <span class="built_in">enable</span>  nginx.service      <span class="comment"># 使服务开机启动</span></div><div class="line">systemctl <span class="built_in">disable</span> nginx.service      <span class="comment"># 取消服务开机启动</span></div><div class="line">systemctl list -units --<span class="built_in">type</span>=service <span class="comment"># 查看所有已启动的服务</span></div></pre></td></tr></table></figure>
<p>彻底关闭服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">systemctl status nginx.service</div><div class="line">systemctl stop nginx.service</div><div class="line">systemctl <span class="built_in">disable</span> nginx.service</div></pre></td></tr></table></figure>
<h2 id="systemctl-与-旧指令-chkconfig-service-对比"><a href="#systemctl-与-旧指令-chkconfig-service-对比" class="headerlink" title="systemctl 与 旧指令 chkconfig service 对比"></a>systemctl 与 旧指令 chkconfig service 对比</h2><table>
<thead>
<tr>
<th>任务</th>
<th>旧指令</th>
<th>新指令</th>
</tr>
</thead>
<tbody>
<tr>
<td>使某服务自动启动</td>
<td>chkconfig –level 3 httpd on</td>
<td>systemctl enable httpd.service</td>
</tr>
<tr>
<td>使某服务不自动启动</td>
<td>chkconfig –level 3 httpd off</td>
<td>systemctl disable httpd.service</td>
</tr>
<tr>
<td>检查服务状态</td>
<td>service httpd status</td>
<td>systemctl status httpd.service (服务详细信息) systemctl is-active httpd.service (仅显示是否 Active)</td>
</tr>
<tr>
<td>显示所有已启动的服务</td>
<td>chkconfig –list</td>
<td>systemctl list-units –type=service</td>
</tr>
<tr>
<td>启动某服务</td>
<td>service httpd start</td>
<td>systemctl start httpd.service</td>
</tr>
<tr>
<td>停止某服务</td>
<td>service httpd stop</td>
<td>systemctl stop httpd.service</td>
</tr>
<tr>
<td>重启某服务</td>
<td>service httpd restart</td>
<td>systemctl restart httpd.service</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;systemctl 是系统服务管理器命令, 它实际上将 service 和 chkconfig 这两个命令组合到一起&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.lyogvce.me/categories/Linux/"/>
    
      <category term="运维" scheme="http://blog.lyogvce.me/categories/Linux/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="运维" scheme="http://blog.lyogvce.me/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="CentOS" scheme="http://blog.lyogvce.me/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 防火墙 firewalld 使用</title>
    <link href="http://blog.lyogvce.me/2016-10/CentOS-7-Firewalld-Usage.html"/>
    <id>http://blog.lyogvce.me/2016-10/CentOS-7-Firewalld-Usage.html</id>
    <published>2016-10-19T16:00:00.000Z</published>
    <updated>2017-07-16T02:26:59.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Centos 7 使用 firewalld 代替了原来的 iptables, 最大的好处有两个:</p>
<ol>
<li>支持动态更新, 不用重启服务</li>
<li>就是加入了防火墙的 “zone” 概念</li>
</ol>
<a id="more"></a>
<p>firewalld 有图形界面和工具界面, 图形界面请参照官方文档</p>
<p>firewalld 的字符界面管理工具是 <code>firewall-cmd</code></p>
<p>firewalld 默认配置文件有两个: <code>/usr/lib/firewalld/</code> (系统配置, 尽量不要修改) 和 <code>/etc/firewalld/</code> (用户配置地址)</p>
<h3 id="zone-概念"><a href="#zone-概念" class="headerlink" title="zone 概念"></a>zone 概念</h3><p>硬件防火墙默认一般有三个区, firewalld 引入了这一概念, 系统默认存在以下区域 (根据文档自己理解, 如果有误请指正):</p>
<ul>
<li>drop: 默认丢弃所有包</li>
<li>block: 拒绝所有外部连接, 允许内部发起的连接</li>
<li>public: 指定外部连接可以进入</li>
<li>external: 这个不太明白, 功能上和上面相同, 允许指定的外部连接</li>
<li>dmz: 和硬件防火墙一样, 受限制的公共连接可以进入</li>
<li>work: 工作区, 概念和 workgoup 一样, 也是指定的外部连接允许</li>
<li>home: 类似家庭组</li>
<li>internal: 信任所有连接</li>
</ul>
<p>对防火墙不算太熟悉, 还不太明白。</p>
<p>public、external、dmz、work、home 从功能上都需要自定义允许连接, 具体使用上的区别还需高人指点</p>
<h2 id="管理-firewalld"><a href="#管理-firewalld" class="headerlink" title="管理 firewalld"></a>管理 firewalld</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">yum install firewalld firewall-config  <span class="comment"># 安装 firewalld</span></div><div class="line"></div><div class="line">systemctl <span class="built_in">enable</span> firewalld   <span class="comment"># 设置开机自启动</span></div><div class="line">systemctl <span class="built_in">disable</span> firewalld  <span class="comment"># 取消开机自启动</span></div><div class="line">systemctl start firewalld    <span class="comment"># 启动</span></div><div class="line">systemctl stop firewalld     <span class="comment"># 停止</span></div><div class="line">systemctl restart firewalld  <span class="comment"># 重启防火墙</span></div><div class="line">systemctl status firewalld   <span class="comment"># 查看防火墙状态</span></div></pre></td></tr></table></figure>
<h2 id="查看-firewalld-信息"><a href="#查看-firewalld-信息" class="headerlink" title="查看 firewalld 信息"></a>查看 firewalld 信息</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">firewall-cmd --state                       <span class="comment"># 状态</span></div><div class="line">firewall-cmd --<span class="built_in">help</span>                        <span class="comment"># 帮助</span></div><div class="line">firewall-cmd --version                     <span class="comment"># 版本</span></div><div class="line">firewall-cmd --get-active-zones            <span class="comment"># 区域信息</span></div><div class="line">firewall-cmd --get-zone-of-interface=eth0  <span class="comment"># 指定接口所属区域</span></div></pre></td></tr></table></figure>
<h2 id="配置-firewalld"><a href="#配置-firewalld" class="headerlink" title="配置 firewalld"></a>配置 firewalld</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 配置完成后都要更新防火墙规则</span></div><div class="line">firewall-cmd --reload            <span class="comment"># 更新防火墙规则</span></div><div class="line">firewall-cmd --complete-reload   <span class="comment"># 两者的区别就是第一个无需断开连接, 就是 firewalld 特性之一动态添加规则, 第二个需要断开连接, 类似重启服务</span></div><div class="line"></div><div class="line"><span class="comment"># 打开端口 -- 这个最常用</span></div><div class="line">firewall-cmd --zone=public --list-ports                      <span class="comment"># 查看区域 public 所有打开的端口</span></div><div class="line">firewall-cmd --zone=public --add-port=8080/tcp               <span class="comment"># 加入一个端口到区域 public</span></div><div class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent   <span class="comment"># 永久生效</span></div><div class="line"></div><div class="line">firewall-cmd --zone=public --add-source=192.168.125.0/24     <span class="comment"># 加入源 IP 到区域 public</span></div><div class="line">firewall-cmd --zone=public --add-source=192.168.125.0/24 --permanent  <span class="comment"># 永久生效</span></div><div class="line"></div><div class="line">firewall-cmd --zone=public --add-interface=eth0              <span class="comment"># 将接口添加到区域, 默认接口都在 public</span></div><div class="line">firewall-cmd --zone=public --add-interface=eth0 --permanent  <span class="comment"># 永久生效</span></div><div class="line"></div><div class="line">firewall-cmd --<span class="built_in">set</span>-default-zone=public <span class="comment"># 设置默认接口区域, 立即生效无需重启</span></div><div class="line"></div><div class="line">firewall-cmd --panic-on     <span class="comment"># 拒绝所有包</span></div><div class="line">firewall-cmd --panic-off    <span class="comment"># 取消拒绝状态</span></div><div class="line">firewall-cmd --query-panic  <span class="comment"># 查看是否拒绝</span></div><div class="line"></div><div class="line"><span class="comment"># 打开一个服务, 类似于将端口可视化, 服务需要在配置文件中添加, /etc/firewalld 目录下有 services 文件夹, 这个不详细说了, 详情参考文档</span></div><div class="line">firewall-cmd --zone=work --add-service=smtp</div><div class="line"></div><div class="line"><span class="comment"># 移除服务</span></div><div class="line">firewall-cmd --zone=work --remove-service=smtp</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Centos 7 使用 firewalld 代替了原来的 iptables, 最大的好处有两个:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;支持动态更新, 不用重启服务&lt;/li&gt;
&lt;li&gt;就是加入了防火墙的 “zone” 概念&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.lyogvce.me/categories/Linux/"/>
    
      <category term="运维" scheme="http://blog.lyogvce.me/categories/Linux/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="运维" scheme="http://blog.lyogvce.me/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="CentOS" scheme="http://blog.lyogvce.me/tags/CentOS/"/>
    
      <category term="防火墙" scheme="http://blog.lyogvce.me/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 软件仓库 国内镜像源</title>
    <link href="http://blog.lyogvce.me/2016-10/CentOS-Repo-Mirror.html"/>
    <id>http://blog.lyogvce.me/2016-10/CentOS-Repo-Mirror.html</id>
    <published>2016-10-18T16:00:00.000Z</published>
    <updated>2017-07-16T02:26:59.114Z</updated>
    
    <content type="html"><![CDATA[<p>163 源: <a href="http://mirrors.163.com/.help/centos.html" target="_blank" rel="external">http://mirrors.163.com/.help/centos.html</a></p>
<p>阿里源: <a href="http://mirrors.aliyun.com/help/centos" target="_blank" rel="external">http://mirrors.aliyun.com/help/centos</a> – 可能要去掉 aliyuncs.com 的 url</p>
<a id="more"></a>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;163 源: &lt;a href=&quot;http://mirrors.163.com/.help/centos.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://mirrors.163.com/.help/centos.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;阿里源: &lt;a href=&quot;http://mirrors.aliyun.com/help/centos&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://mirrors.aliyun.com/help/centos&lt;/a&gt; – 可能要去掉 aliyuncs.com 的 url&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.lyogvce.me/categories/Linux/"/>
    
      <category term="运维" scheme="http://blog.lyogvce.me/categories/Linux/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="运维" scheme="http://blog.lyogvce.me/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="CentOS" scheme="http://blog.lyogvce.me/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>Linux 配置 之 英文个人目录</title>
    <link href="http://blog.lyogvce.me/2016-10/Chinese-Linux-With-English-Directory.html"/>
    <id>http://blog.lyogvce.me/2016-10/Chinese-Linux-With-English-Directory.html</id>
    <published>2016-10-17T16:00:00.000Z</published>
    <updated>2017-07-16T02:26:59.154Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h2><p>终端:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> LANG=en_US</div><div class="line">xdg-user-dirs-gtk-update</div></pre></td></tr></table></figure>
<p>这时会弹出一个配置界面, 提示是否将中文目录切换为英文目录, 确定. 系统会删除没有内容的中文目录, 而有内容的目录会保持. 并创建 8 个相应的英文目录: “Desktop”, “Download”, “Templates”, “Public”, “Documents”, “Music”, “Pictures”, “Videos”.</p>
<a id="more"></a>
<p>这时常用中文目录已经变成英文目录.</p>
<h2 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> LANG=zh_CN.UTF-8</div><div class="line">xdg-user-dirs-gtk-update</div></pre></td></tr></table></figure>
<p>这次选否, 且选上 <code>不再提示</code>.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Step-1&quot;&gt;&lt;a href=&quot;#Step-1&quot; class=&quot;headerlink&quot; title=&quot;Step 1&quot;&gt;&lt;/a&gt;Step 1&lt;/h2&gt;&lt;p&gt;终端:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;export&lt;/span&gt; LANG=en_US&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;xdg-user-dirs-gtk-update&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这时会弹出一个配置界面, 提示是否将中文目录切换为英文目录, 确定. 系统会删除没有内容的中文目录, 而有内容的目录会保持. 并创建 8 个相应的英文目录: “Desktop”, “Download”, “Templates”, “Public”, “Documents”, “Music”, “Pictures”, “Videos”.&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.lyogvce.me/categories/Linux/"/>
    
      <category term="配置" scheme="http://blog.lyogvce.me/categories/Linux/%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="Linux 配置" scheme="http://blog.lyogvce.me/tags/Linux-%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Linux 配置 之 获取 Root 权限</title>
    <link href="http://blog.lyogvce.me/2016-05/Obtain-Root-Permission.html"/>
    <id>http://blog.lyogvce.me/2016-05/Obtain-Root-Permission.html</id>
    <published>2016-05-12T16:00:00.000Z</published>
    <updated>2017-07-16T02:26:58.743Z</updated>
    
    <content type="html"><![CDATA[<p>本文是用于找回虚拟机中的 Linux Root 密码。实体机应该也可以使用。:)</p>
<a id="more"></a>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="1-启动虚拟机"><a href="#1-启动虚拟机" class="headerlink" title="1. 启动虚拟机"></a>1. 启动虚拟机</h3><h3 id="2-在开启过程中一直按-ESC-进入如下界面"><a href="#2-在开启过程中一直按-ESC-进入如下界面" class="headerlink" title="2. 在开启过程中一直按 ESC 进入如下界面"></a>2. 在开启过程中一直按 <code>ESC</code> 进入如下界面</h3><p><img src="../images/Obtain-Root-Permission/1.png" alt="img"></p>
<p>如果没有进入该界面而是直接开机了, 请重启并不断尝试按 <code>ESC</code> 直至出现该界面</p>
<p>进入该界面后选中第二项 <code>Advanced Options for Ubuntu</code> 按下 <code>Enter</code></p>
<h3 id="3-进入如下界面"><a href="#3-进入如下界面" class="headerlink" title="3. 进入如下界面"></a>3. 进入如下界面</h3><p><img src="../images/Obtain-Root-Permission/2.png" alt="img"></p>
<p>选中第二项, 也就是带有 <code>recovery mode</code> 的选项, 注意, 千万别回车! 按下 <code>e</code> 键进入编辑模式</p>
<h3 id="4-进入如下界面后-注意红圈内容"><a href="#4-进入如下界面后-注意红圈内容" class="headerlink" title="4. 进入如下界面后, 注意红圈内容"></a>4. 进入如下界面后, 注意红圈内容</h3><p><img src="../images/Obtain-Root-Permission/3.png" alt="img"></p>
<p>将其删掉并修改为: <code>quiet splash rw init=/bin/bash</code></p>
<p><img src="../images/Obtain-Root-Permission/4.png" alt="img"></p>
<h3 id="5-按-ctrl-x-或者-F10-执行"><a href="#5-按-ctrl-x-或者-F10-执行" class="headerlink" title="5. 按 ctrl+x 或者 F10 执行"></a>5. 按 <code>ctrl+x</code> 或者 <code>F10</code> 执行</h3><p>进入如下界面:</p>
<p><img src="../images/Obtain-Root-Permission/5.png" alt="img"></p>
<h3 id="6-输入代码-passwd-root"><a href="#6-输入代码-passwd-root" class="headerlink" title="6. 输入代码: passwd root"></a>6. 输入代码: <code>passwd root</code></h3><p><img src="../images/Obtain-Root-Permission/6.png" alt="img"></p>
<p>按下 <code>Enter</code> 执行, 然后提示你输入新密码:</p>
<p><img src="../images/Obtain-Root-Permission/7.png" alt="img"></p>
<p>输入两次后修改成功, 然后重启就好了.</p>
<p>用 guest 用户登录, 在终端输入 <code>su -</code> 可切临时换到 root 账户.</p>
<p>至此 root 密码就是你设置的新密码, 完成.</p>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>另外  修改好密码后, guest 不能 sudo, 因为 guest 用户没有 sudo 权限, 需要作如下修改:</p>
<ol>
<li>以 guest 用户登录:</li>
<li>打开终端  输入 <code>su -</code> 切换到 root 用户:</li>
<li>输入: vim /etc/sudoers</li>
<li>在 <code>%sudo ALL=(ALL:ALL) ALL</code> 的下一行添加 <code>guest  ALL=(ALL)  ALL</code>, 保存退出</li>
</ol>
<p>这样 guest 就有 sudo 权限了.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是用于找回虚拟机中的 Linux Root 密码。实体机应该也可以使用。:)&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.lyogvce.me/categories/Linux/"/>
    
      <category term="配置" scheme="http://blog.lyogvce.me/categories/Linux/%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="Linux 配置" scheme="http://blog.lyogvce.me/tags/Linux-%E9%85%8D%E7%BD%AE/"/>
    
      <category term="Root" scheme="http://blog.lyogvce.me/tags/Root/"/>
    
  </entry>
  
  <entry>
    <title>公共 DNS 解析</title>
    <link href="http://blog.lyogvce.me/2016-05/Public-DNS.html"/>
    <id>http://blog.lyogvce.me/2016-05/Public-DNS.html</id>
    <published>2016-05-02T16:00:00.000Z</published>
    <updated>2017-07-16T02:26:58.785Z</updated>
    
    <content type="html"><![CDATA[<h2 id="国外-DNS-服务器地址"><a href="#国外-DNS-服务器地址" class="headerlink" title="国外 DNS 服务器地址"></a>国外 DNS 服务器地址</h2><ul>
<li>Google DNS         (8.8.8.8, 8.8.4.4)</li>
<li>OpenDNS            (208.67.222.222, 208.67.220.220)</li>
<li>OpenDNS Family     (208.67.222.123, 208.67.220.123)</li>
<li>V2EX DNS           (199.91.73.222, 178.79.131.110)</li>
<li>Comodo Secure      (8.26.56.26, 8.20.247.20)</li>
<li>UltraDNS           (156.154.70.1, 156.154.71.1)</li>
<li>Norton ConnectSafe (199.85.126.10, 199.85.127.10)</li>
</ul>
<a id="more"></a>
<h2 id="国内-DNS-服务器地址"><a href="#国内-DNS-服务器地址" class="headerlink" title="国内 DNS 服务器地址"></a>国内 DNS 服务器地址</h2><ul>
<li>OneDNS       (112.124.47.27)</li>
<li>OpenerDNS    (42.120.21.30)</li>
<li>aliDNS       (223.5.5.5, 223.6.6.6)</li>
<li>114DNS       (114.114.114.114, 114.114.115.115)</li>
<li>114DNS 安全版 (114.114.114.119, 114.114.115.119)</li>
<li>114DNS 家庭版 (114.114.114.110, 114.114.115.110)</li>
<li>阿里 DNS      (223.5.5.5, 223.6.6.6)</li>
<li>百度 DNS      (180.76.76.76)</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;国外-DNS-服务器地址&quot;&gt;&lt;a href=&quot;#国外-DNS-服务器地址&quot; class=&quot;headerlink&quot; title=&quot;国外 DNS 服务器地址&quot;&gt;&lt;/a&gt;国外 DNS 服务器地址&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Google DNS         (8.8.8.8, 8.8.4.4)&lt;/li&gt;
&lt;li&gt;OpenDNS            (208.67.222.222, 208.67.220.220)&lt;/li&gt;
&lt;li&gt;OpenDNS Family     (208.67.222.123, 208.67.220.123)&lt;/li&gt;
&lt;li&gt;V2EX DNS           (199.91.73.222, 178.79.131.110)&lt;/li&gt;
&lt;li&gt;Comodo Secure      (8.26.56.26, 8.20.247.20)&lt;/li&gt;
&lt;li&gt;UltraDNS           (156.154.70.1, 156.154.71.1)&lt;/li&gt;
&lt;li&gt;Norton ConnectSafe (199.85.126.10, 199.85.127.10)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="网络" scheme="http://blog.lyogvce.me/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="DNS" scheme="http://blog.lyogvce.me/tags/DNS/"/>
    
  </entry>
  
</feed>
